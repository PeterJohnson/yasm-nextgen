//
// ELF object format
//
//  Copyright (C) 2003-2007  Michael Urman
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND OTHER CONTRIBUTORS ``AS IS''
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR OTHER CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Notes
//
// elf-objfmt uses the "linking" view of an ELF file:
// ELF header, an optional program header table, several sections,
// and a section header table
//
// The ELF header tells us some overall program information,
//   where to find the PHT (if it exists) with phnum and phentsize,
//   and where to find the SHT with shnum and shentsize
//
// The PHT doesn't seem to be generated by NASM for elftest.asm
//
// The SHT
//
// Each Section is spatially disjoint, and has exactly one SHT entry.
//
#include "util.h"

#include "llvm/Support/MemoryBuffer.h"
#include "yasmx/Support/bitcount.h"
#include "yasmx/Support/Compose.h"
#include "yasmx/Support/errwarn.h"
#include "yasmx/Support/registry.h"
#include "yasmx/Support/scoped_array.h"
#include "yasmx/Arch.h"
#include "yasmx/BytecodeContainer_util.h"
#include "yasmx/BytecodeOutput.h"
#include "yasmx/Bytecode.h"
#include "yasmx/Directive.h"
#include "yasmx/DirHelpers.h"
#include "yasmx/Errwarns.h"
#include "yasmx/Location_util.h"
#include "yasmx/Object.h"
#include "yasmx/ObjectFormat.h"
#include "yasmx/Object_util.h"
#include "yasmx/NameValue.h"
#include "yasmx/Section.h"
#include "yasmx/StringTable.h"
#include "yasmx/Symbol_util.h"

#include "ElfConfig.h"
#include "ElfMachine.h"
#include "ElfReloc.h"
#include "ElfSection.h"
#include "ElfSymbol.h"
#include "ElfTypes.h"


namespace yasm
{
namespace objfmt
{
namespace elf
{

static inline bool
isLocal(const Symbol& sym)
{
    int vis = sym.getVisibility();
    return (vis == Symbol::LOCAL || (vis & Symbol::DLOCAL) != 0);
}

class ElfObject : public ObjectFormat
{
public:
    ElfObject(const ObjectFormatModule& module,
              Object& object,
              unsigned int bits=0);
    ~ElfObject() {}

    static llvm::StringRef getName() { return "ELF"; }
    static llvm::StringRef getKeyword() { return "elf"; }
    static llvm::StringRef getExtension() { return ".o"; }
    static unsigned int getDefaultX86ModeBits() { return 0; }
    static llvm::StringRef getDefaultDebugFormatKeyword() { return "null"; }
    static std::vector<llvm::StringRef> getDebugFormatKeywords();
    static bool isOkObject(Object& object) { return true; }
    static bool Taste(const llvm::MemoryBuffer& in,
                      /*@out@*/ std::string* arch_keyword,
                      /*@out@*/ std::string* machine)
    { return false; }

    void AddDirectives(Directives& dirs, llvm::StringRef parser);

    void InitSymbols(llvm::StringRef parser);

    void Read(const llvm::MemoryBuffer& in);
    void Output(llvm::raw_fd_ostream& os, bool all_syms, Errwarns& errwarns,
                Diagnostic& diags);

    Section* AddDefaultSection();
    Section* AppendSection(llvm::StringRef name, clang::SourceLocation source);

    ElfSymbol& BuildSymbol(Symbol& sym);
    void BuildExtern(Symbol& sym);
    void BuildGlobal(Symbol& sym);
    void BuildCommon(Symbol& sym);
    void setSymbolSectionValue(Symbol& sym, ElfSymbol& elfsym);
    void FinalizeSymbol(Symbol& sym, StringTable& strtab, bool local_names);

    void DirGasSection(DirectiveInfo& info);
    void DirSection(DirectiveInfo& info);
    void DirType(DirectiveInfo& info);
    void DirSize(DirectiveInfo& info);
    void DirWeak(DirectiveInfo& info);
    void DirIdent(DirectiveInfo& info);

    ElfConfig m_config;                     // ELF configuration
    util::scoped_ptr<ElfMachine> m_machine; // ELF machine interface

    ElfSymbol* m_file_elfsym;               // .file symbol
    SymbolRef m_dotdotsym;                  // ..sym symbol
};

bool TasteCommon(const llvm::MemoryBuffer& in,
                 /*@out@*/ std::string* arch_keyword,
                 /*@out@*/ std::string* machine,
                 ElfClass cls);

class Elf32Object : public ElfObject
{
public:
    Elf32Object(const ObjectFormatModule& module, Object& object)
        : ElfObject(module, object, 32)
    {}

    static llvm::StringRef getName() { return "ELF (32-bit)"; }
    static llvm::StringRef getKeyword() { return "elf32"; }
    static llvm::StringRef getExtension() { return ElfObject::getExtension(); }
    static unsigned int getDefaultX86ModeBits() { return 32; }

    static llvm::StringRef getDefaultDebugFormatKeyword()
    { return ElfObject::getDefaultDebugFormatKeyword(); }
    static std::vector<llvm::StringRef> getDebugFormatKeywords()
    { return ElfObject::getDebugFormatKeywords(); }

    static bool isOkObject(Object& object)
    { return isOkElfMachine(*object.getArch(), ELFCLASS32); }

    // For tasting, let main elf handle it.
    static bool Taste(const llvm::MemoryBuffer& in,
                      /*@out@*/ std::string* arch_keyword,
                      /*@out@*/ std::string* machine)
    { return TasteCommon(in, arch_keyword, machine, ELFCLASS32); }
};

class Elf64Object : public ElfObject
{
public:
    Elf64Object(const ObjectFormatModule& module, Object& object)
        : ElfObject(module, object, 64)
    {}

    static llvm::StringRef getName() { return "ELF (64-bit)"; }
    static llvm::StringRef getKeyword() { return "elf64"; }
    static llvm::StringRef getExtension() { return ElfObject::getExtension(); }
    static unsigned int getDefaultX86ModeBits() { return 64; }

    static llvm::StringRef getDefaultDebugFormatKeyword()
    { return ElfObject::getDefaultDebugFormatKeyword(); }
    static std::vector<llvm::StringRef> getDebugFormatKeywords()
    { return ElfObject::getDebugFormatKeywords(); }

    static bool isOkObject(Object& object)
    { return isOkElfMachine(*object.getArch(), ELFCLASS64); }

    // For tasting, let main elf handle it.
    static bool Taste(const llvm::MemoryBuffer& in,
                      /*@out@*/ std::string* arch_keyword,
                      /*@out@*/ std::string* machine)
    { return TasteCommon(in, arch_keyword, machine, ELFCLASS64); }
};

ElfObject::ElfObject(const ObjectFormatModule& module,
                     Object& object,
                     unsigned int bits)
    : ObjectFormat(module, object)
    , m_machine(0)
    , m_file_elfsym(0)
    , m_dotdotsym(0)
{
    if (bits == 32)
        m_config.cls = ELFCLASS32;
    else if (bits == 64)
        m_config.cls = ELFCLASS64;
    else if (bits != 0)
        throw ValueError(String::Compose(N_("unknown ELF bits setting %1"),
                                         bits));

    m_machine.reset(CreateElfMachine(*m_object.getArch(),
                                     m_config.cls).release());
    m_machine->Configure(&m_config);
}

bool
TasteCommon(const llvm::MemoryBuffer& in,
            /*@out@*/ std::string* arch_keyword,
            /*@out@*/ std::string* machine,
            ElfClass cls)
{
    ElfConfig config;

    // Read header
    if (!config.ReadProgramHeader(in))
        return false;

    // Check class
    if (config.cls != cls)
        return false;

    // for now, just handle this here
    switch (config.machine_type)
    {
        case EM_386:
            arch_keyword->assign("x86");
            machine->assign("x86");
            break;
        case EM_X86_64:
            arch_keyword->assign("x86");
            machine->assign("amd64");
            break;
        default:
            return false;
    }
    return true;
}

static inline StringTable
LoadStringTable(const llvm::MemoryBuffer& in, const ElfSection& elfsect)
{
    const char* start = in.getBufferStart() + elfsect.getFileOffset();
    const char* end = start + elfsect.getSize().getUInt();
    if (end > in.getBufferEnd())
        throw Error(N_("could not read string table data"));
    return StringTable(start, end);
}

void
ElfObject::Read(const llvm::MemoryBuffer& in)
{
    // Read header
    if (!m_config.ReadProgramHeader(in))
        throw Error(N_("not an ELF file"));

    // Can't handle files without section table yet
    if (m_config.secthead_pos == 0)
        throw Error(N_("no section table"));

    // Read section string table (needed for section names)
    std::auto_ptr<ElfSection>
        shstrtab_sect(new ElfSection(m_config, in, m_config.shstrtab_index));
    StringTable shstrtab = LoadStringTable(in, *shstrtab_sect);

    // Read all section headers

    // owned storage for "misc" sections (e.g. relocation sections)
    stdx::ptr_vector<ElfSection> misc_sections;
    stdx::ptr_vector_owner<ElfSection> misc_sections_owner(misc_sections);
    misc_sections.reserve(m_config.secthead_count);

    // indexed array of all ElfSections by section index
    util::scoped_array<ElfSection*>
        elfsects(new ElfSection*[m_config.secthead_count]);
    // indexed array of all Sections by section index
    util::scoped_array<Section*>
        sections(new Section*[m_config.secthead_count]);

    // special sections
    ElfSection* strtab_sect = 0;
    ElfSection* symtab_sect = 0;

    // read section headers
    for (unsigned int i=0; i<m_config.secthead_count; ++i)
    {
        // read section header and save by index
        std::auto_ptr<ElfSection> elfsect(new ElfSection(m_config, in, i));
        elfsects[i] = elfsect.get();

        llvm::StringRef sectname = shstrtab.getString(elfsect->getName());
        if (sectname == ".strtab")
        {
            strtab_sect = elfsect.get();
        }
        else if (sectname == ".symtab")
        {
            symtab_sect = elfsect.get();
        }

        ElfSectionType secttype = elfsect->getType();
        if (secttype == SHT_NULL ||
            secttype == SHT_SYMTAB ||
            secttype == SHT_STRTAB ||
            secttype == SHT_RELA ||
            secttype == SHT_REL)
        {
            misc_sections.push_back(elfsect.release());
            sections[i] = 0;

            // try to pick these up by section type if not set
            if (secttype == SHT_SYMTAB && symtab_sect == 0)
                symtab_sect = elfsect.get();
            else if (secttype == SHT_STRTAB && strtab_sect == 0)
                strtab_sect = elfsect.get();

            // if any section is RELA, set config to RELA
            if (secttype == SHT_RELA)
                m_config.rela = true;
        }
        else
        {
            std::auto_ptr<Section> section = elfsect->CreateSection(shstrtab);
            elfsect->LoadSectionData(*section, in);
            sections[i] = section.get();

            // Associate section data with section
            section->AddAssocData(elfsect);

            // Add section to object
            m_object.AppendSection(section);
        }
    }

    // Symbol table by index (needed for relocation lookups by index)
    std::vector<SymbolRef> symtab;

    // read symtab string table and symbol table (if present)
    if (symtab_sect != 0)
    {
        // get string table section index from symtab link field if reasonable
        ElfSectionIndex link = symtab_sect->getLink();
        if (link < m_config.secthead_count &&
            elfsects[link]->getType() == SHT_STRTAB)
            strtab_sect = elfsects[link];

        if (strtab_sect == 0)
            throw Error(N_("could not find symbol string table"));

        // load symbol string table
        StringTable strtab = LoadStringTable(in, *strtab_sect);

        // load symbol table
        m_config.ReadSymbolTable(in, *symtab_sect, symtab, m_object, strtab,
                                 &sections[0]);
    }

    // go through misc sections to load relocations
    for (unsigned int i=0; i<m_config.secthead_count; ++i)
    {
        ElfSection* reloc_sect = elfsects[i];
        ElfSectionType secttype = reloc_sect->getType();
        if (secttype != SHT_REL && secttype != SHT_RELA)
            continue;

        // get symbol table section index from link field (if valid)
        ElfSection* rel_symtab_sect = symtab_sect;
        ElfSectionIndex link = reloc_sect->getLink();
        if (link < m_config.secthead_count &&
            elfsects[link]->getType() == SHT_SYMTAB)
        {
            if (rel_symtab_sect != elfsects[link])
            {
                throw Error(N_("only one symbol table supported"));
            }
        }

        // section relocs apply to is indicated by info field
        ElfSectionIndex info = reloc_sect->getInfo();
        if (link >= m_config.secthead_count || sections[info] == 0)
            continue;

        // load relocations
        elfsects[info]->ReadRelocs(in, *reloc_sect, *sections[info],
                                   *m_machine, symtab, secttype == SHT_RELA);
    }
}

void
ElfObject::InitSymbols(llvm::StringRef parser)
{
    // Add .file symbol
    SymbolRef filesym = m_object.AppendSymbol(".file");
    filesym->DefineSpecial(Symbol::LOCAL);

    std::auto_ptr<ElfSymbol> elfsym(new ElfSymbol());
    elfsym->setSectionIndex(SHN_ABS);
    elfsym->setBinding(STB_LOCAL);
    elfsym->setType(STT_FILE);
    m_file_elfsym = elfsym.get();

    filesym->AddAssocData(elfsym);

    // Create ..sym special symbol (NASM only)
    if (parser.equals_lower("nasm"))
    {
        m_dotdotsym = m_object.AddSpecialSymbol("sym");
        m_dotdotsym->DefineSpecial(Symbol::EXTERN);
    }

    // Create machine-specific special symbols
    m_machine->AddSpecialSymbols(m_object, parser);
}

ElfSymbol&
ElfObject::BuildSymbol(Symbol& sym)
{
    ElfSymbol* elfsym = sym.getAssocData<ElfSymbol>();

    if (!elfsym)
    {
        elfsym = new ElfSymbol;
        sym.AddAssocData(std::auto_ptr<ElfSymbol>(elfsym));
    }

    return *elfsym;
}

void
ElfObject::BuildExtern(Symbol& sym)
{
    const NameValues* objext_nvs = getObjextNameValues(sym);

    if (objext_nvs)
    {
        for (NameValues::const_iterator nv=objext_nvs->begin(),
             end=objext_nvs->end(); nv != end; ++nv)
        {
            if (nv->isString())
            {
                throw TypeError(String::Compose(
                    N_("unrecognized symbol type `%1'"), nv->getString()));
            }
        }
    }

    ElfSymbol& elfsym = BuildSymbol(sym);
    elfsym.setBinding(STB_GLOBAL);
}

static bool
GlobalNameValueFallback(NameValue& nv,
                        Object* object,
                        clang::SourceLocation source,
                        Expr::Ptr* size)

{
    if (!nv.isExpr() && nv.isId())
    {
        throw TypeError(String::Compose(N_("unrecognized symbol type `%s'"),
                                        nv.getId()));
    }
    else if (nv.isExpr() && size->get() == 0)
    {
        *size = nv.ReleaseExpr(*object, source);
        return true;
    }
    else
        return DirNameValueWarn(nv);
}

static inline void
GlobalSetVis(NameValue& nv, ElfSymbolVis* vis_out, unsigned int* vis_count,
             ElfSymbolVis vis)
{
    *vis_out = vis;
    *vis_count = *vis_count + 1;
}


void
ElfObject::BuildGlobal(Symbol& sym)
{
    Expr::Ptr size(0);
    unsigned long type = STT_NOTYPE;    // ElfSymbolType
    ElfSymbolVis vis = STV_DEFAULT;
    unsigned int nvis = 0;

    DirHelpers helpers;

    helpers.Add("function", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_FUNC));
    helpers.Add("data", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_OBJECT));
    helpers.Add("object", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_OBJECT));
    helpers.Add("object", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_OBJECT));
    helpers.Add("internal", false,
                BIND::bind(&GlobalSetVis, _1, &vis, &nvis, STV_INTERNAL));
    helpers.Add("hidden", false,
                BIND::bind(&GlobalSetVis, _1, &vis, &nvis, STV_HIDDEN));
    helpers.Add("protected", false,
                BIND::bind(&GlobalSetVis, _1, &vis, &nvis, STV_PROTECTED));

    NameValues* objext_nvs = getObjextNameValues(sym);
    if (objext_nvs)
    {
        helpers(objext_nvs->begin(), objext_nvs->end(),
                BIND::bind(&GlobalNameValueFallback, _1, &m_object,
                           sym.getDeclSource(), &size));
    }

    if (nvis > 1)
    {
        setWarn(WARN_GENERAL,
            N_("More than one symbol visibility provided; using last"));
    }

    ElfSymbol& elfsym = BuildSymbol(sym);
    elfsym.setBinding(STB_GLOBAL);
    elfsym.setType(static_cast<ElfSymbolType>(type));
    elfsym.setVisibility(vis);
    if (size.get() != 0)
        elfsym.setSize(*size, sym.getDeclSource());
}

void
ElfObject::BuildCommon(Symbol& sym)
{
    NameValues* objext_nvs = getObjextNameValues(sym);
    unsigned long addralign = 0;

    if (objext_nvs)
    {
        for (NameValues::iterator nv=objext_nvs->begin(),
             end=objext_nvs->end(); nv != end; ++nv)
        {
            if (!nv->getName().empty())
            {
                setWarn(WARN_GENERAL, String::Compose(
                    N_("Unrecognized qualifier `%1'"), nv->getName()));
                continue;
            }

            if (!nv->isExpr())
                throw ValueError(N_("alignment constraint is not an integer"));

            std::auto_ptr<Expr> align_expr =
                nv->ReleaseExpr(m_object, sym.getDeclSource());
            if (!align_expr->isIntNum())
                throw ValueError(N_("alignment constraint is not an integer"));
            addralign = align_expr->getIntNum().getUInt();

            // Alignments must be a power of two.
            if (!isExp2(addralign))
            {
                throw ValueError(
                    N_("alignment constraint is not a power of two"));
            }
        }
    }

    ElfSymbol& elfsym = BuildSymbol(sym);
    elfsym.setSectionIndex(SHN_COMMON);
    elfsym.setBinding(STB_GLOBAL);
    elfsym.setSize(*getCommonSize(sym), sym.getDeclSource());
    elfsym.setValue(addralign);
}

void
ElfObject::setSymbolSectionValue(Symbol& sym, ElfSymbol& elfsym)
{
    Location loc;
    if (!sym.getLabel(&loc))
        return;

    if (loc.bc)
    {
        elfsym.setSection(loc.bc->getContainer()->AsSection());
        elfsym.setValue(loc.getOffset());
    }
}

void
ElfObject::FinalizeSymbol(Symbol& sym, StringTable& strtab, bool local_names)
{
    int vis = sym.getVisibility();
    int status = sym.getStatus();
    ElfSymbol* elfsym = sym.getAssocData<ElfSymbol>();

    if (vis & Symbol::EXTERN)
    {
        BuildExtern(sym);
        elfsym = sym.getAssocData<ElfSymbol>();
        elfsym->setName(strtab.getIndex(sym.getName()));
        return;
    }

    if (vis & Symbol::COMMON)
    {
        BuildCommon(sym);
        elfsym = sym.getAssocData<ElfSymbol>();
        elfsym->setName(strtab.getIndex(sym.getName()));
        // fall through (check below catches undefined case)
    }

    // Ignore any undefined at this point.
    if (!(status & Symbol::DEFINED))
        return;

    if (elfsym)
        ;
    else if (vis & Symbol::GLOBAL)
    {
        BuildGlobal(sym);
        elfsym = sym.getAssocData<ElfSymbol>();
        elfsym->setName(strtab.getIndex(sym.getName()));
    }
    else
    {
        Location loc = {0, 0};
        if (!sym.getLabel(&loc))
        {
            if (!sym.getEqu() && !sym.isAbsoluteSymbol())
                return;
        }

        Section* sect = 0;
        if (loc.bc)
            sect = loc.bc->getContainer()->AsSection();

        // Locals (except when debugging) do not need to be
        // in the symbol table, unless they're a section.
        bool is_sect = false;
        if (sect)
        {
            ElfSection* elfsect = sect->getAssocData<ElfSection>();
            if (elfsect && elfsect->getSymbol() == &sym)
                is_sect = true;
        }

        if (!local_names && !is_sect)
            return;

        if (sym.getEqu() && !sym.isAbsoluteSymbol())
            return;

        elfsym = &BuildSymbol(sym);
        if (local_names || is_sect)
            elfsym->setName(strtab.getIndex(sym.getName()));
        if (is_sect)
            elfsym->setType(STT_SECTION);
    }

    setSymbolSectionValue(sym, *elfsym);
}

class ElfOutput : public BytecodeStreamOutput
{
public:
    ElfOutput(llvm::raw_fd_ostream& os, ElfObject& objfmt, Object& object);
    ~ElfOutput();

    void OutputSection(Section& sect,
                       unsigned int* sindex,
                       StringTable& shstrtab,
                       Errwarns& errwarns);

    // OutputBytecode overrides
    void ConvertValueToBytes(Value& value,
                             Bytes& bytes,
                             Location loc,
                             int warn);
    void ConvertSymbolToBytes(SymbolRef sym,
                              Bytes& bytes,
                              Location loc,
                              unsigned int valsize,
                              int warn);

private:
    ElfObject& m_objfmt;
    Object& m_object;
    llvm::raw_fd_ostream& m_fd_os;
    BytecodeNoOutput m_no_output;
    SymbolRef m_GOT_sym;
};

ElfOutput::ElfOutput(llvm::raw_fd_ostream& os,
                     ElfObject& objfmt,
                     Object& object)
    : BytecodeStreamOutput(os)
    , m_objfmt(objfmt)
    , m_object(object)
    , m_fd_os(os)
    , m_GOT_sym(object.FindSymbol("_GLOBAL_OFFSET_TABLE_"))
{
}

ElfOutput::~ElfOutput()
{
}

void
ElfOutput::ConvertSymbolToBytes(SymbolRef sym,
                                Bytes& bytes,
                                Location loc,
                                unsigned int valsize,
                                int warn)
{
    std::auto_ptr<ElfReloc> reloc =
        m_objfmt.m_machine->MakeReloc(sym, SymbolRef(0), loc.getOffset(),
                                      false, m_GOT_sym, valsize);

    // allocate .rel[a] sections on a need-basis
    Section* sect = loc.bc->getContainer()->AsSection();
    sect->AddReloc(std::auto_ptr<Reloc>(reloc.release()));

    m_object.getArch()->ToBytes(0, bytes, valsize, 0, warn);
}

void
ElfOutput::ConvertValueToBytes(Value& value,
                               Bytes& bytes,
                               Location loc,
                               int warn)
{
    // We can't handle these types of values
    if (value.isSegOf() || value.isSectionRelative() || value.getRShift() > 0)
        throw TooComplexError(N_("elf: relocation too complex"));

    IntNum intn(0);
    if (value.OutputBasic(bytes, &intn, warn, *m_object.getArch()))
        return;

    if (value.isRelative())
    {
        SymbolRef sym = value.getRelative();
        SymbolRef wrt = value.getWRT();

        if (wrt == m_objfmt.m_dotdotsym)
            wrt = SymbolRef(0);
        else if (wrt && isWRTSymRelative(*wrt))
            ;
        else if (wrt && isWRTPosAdjusted(*wrt))
            intn += loc.getOffset();
        else if (isLocal(*sym))
        {
            // Local symbols need relocation to their section's start, and
            // add in the offset of the bytecode (within the target section)
            // into the abs portion.
            //
            // This is only done if the symbol is relocated against the
            // section instead of the symbol itself.
            Location symloc;
            if (sym->getLabel(&symloc))
            {
                // Relocate to section start
                Section* sym_sect = symloc.bc->getContainer()->AsSection();
                ElfSection* elfsect = sym_sect->getAssocData<ElfSection>();
                assert(elfsect != 0);
                sym = elfsect->getSymbol();

                intn += symloc.getOffset();
            }
        }

        bool pc_rel = false;
        IntNum intn2;
        if (value.CalcPCRelSub(&intn2, loc))
        {
            // Create PC-relative relocation type and fix up absolute portion.
            pc_rel = true;
            intn += intn2;
        }
        else if (value.hasSubRelative())
            throw TooComplexError(N_("elf: relocation too complex"));

        // Create relocation
        Section* sect = loc.bc->getContainer()->AsSection();
        std::auto_ptr<ElfReloc> reloc =
            m_objfmt.m_machine->MakeReloc(sym, wrt, loc.getOffset(), pc_rel,
                                          m_GOT_sym, value.getSize());
        reloc->HandleAddend(&intn, m_objfmt.m_config, value.getInsnStart());
        sect->AddReloc(std::auto_ptr<Reloc>(reloc.release()));
    }

    m_object.getArch()->ToBytes(intn, bytes, value.getSize(), 0, warn);
}
#if 0
static int
elf_objfmt_create_dbg_secthead(yasm_section *sect, /*@null@*/ void *d)
{
    /*@null@*/ elf_objfmt_output_info *info = (elf_objfmt_output_info *)d;
    elf_secthead *shead;
    elf_section_type type=SHT_PROGBITS;
    elf_size entsize=0;
    const char *sectname;
    /*@dependent@*/ yasm_symrec *sym;
    elf_strtab_entry *name;

    shead = yasm_section_get_data(sect, &elf_section_data);
    if (shead)
        return 0;   /* only create new secthead if missing */

    sectname = yasm_section_get_name(sect);
    name = elf_strtab_append_str(info->objfmt_elf->shstrtab, sectname);

    if (yasm__strcasecmp(sectname, ".stab")==0) {
        entsize = 12;
    } else if (yasm__strcasecmp(sectname, ".stabstr")==0) {
        type = SHT_STRTAB;
    } else if (yasm__strncasecmp(sectname, ".debug_", 7)==0) {
        ;
    } else
        yasm_internal_error(N_("Unrecognized section without data"));

    shead = elf_secthead_create(name, type, 0, 0, 0);
    elf_secthead_set_entsize(shead, entsize);

    sym = yasm_symtab_define_label(info->object->symtab, sectname,
                                   yasm_section_bcs_first(sect), 1, 0);
    elf_secthead_set_sym(shead, sym);

    yasm_section_add_data(sect, &elf_section_data, shead);

    return 0;
}
#endif
void
ElfOutput::OutputSection(Section& sect,
                         unsigned int* sindex,
                         StringTable& shstrtab,
                         Errwarns& errwarns)
{
    BytecodeOutput* outputter = this;

    ElfSection* elfsect = sect.getAssocData<ElfSection>();
    assert(elfsect != 0);

    if (elfsect->getAlign() == 0)
        elfsect->setAlign(sect.getAlign());

    elfsect->setName(shstrtab.getIndex(sect.getName()));
    elfsect->setIndex(*sindex);
    *sindex = *sindex + 1;

    uint64_t pos;
    if (sect.isBSS())
    {
        // Don't output BSS sections.
        outputter = &m_no_output;
        pos = 0;    // position = 0 because it's not in the file
    }
    else
    {
        pos = m_os.tell();
        if (m_os.has_error())
            throw IOError(N_("couldn't read position on output stream"));

        if (sect.bytecodes_last().getNextOffset() == 0)
            return;

        m_fd_os.seek(elfsect->setFileOffset(pos));
        if (m_os.has_error())
            throw IOError(N_("couldn't seek on output stream"));
    }

    // Output bytecodes
    for (Section::bc_iterator i=sect.bytecodes_begin(),
         end=sect.bytecodes_end(); i != end; ++i)
    {
        try
        {
            i->Output(*outputter);
            elfsect->AddSize(i->getTotalLen());
        }
        catch (Error& err)
        {
            errwarns.Propagate(i->getSource(), err);
        }
        errwarns.Propagate(i->getSource()); // propagate warnings
    }

    if (errwarns.getNumErrors() > 0)
        return;

    // Sanity check final section size
    assert(elfsect->getSize() == sect.bytecodes_last().getNextOffset());

    // Empty?  Go on to next section
    if (elfsect->isEmpty())
        return;

    // No relocations?  Go on to next section
    if (sect.getRelocs().size() == 0)
        return;

    // need relocation section; set it up
    elfsect->setRelIndex(*sindex);
    *sindex = *sindex + 1;

    // name the relocation section .rel[a].foo
    std::string relname = m_objfmt.m_config.getRelocSectionName(sect.getName());
    elfsect->setRelName(shstrtab.getIndex(relname));
}

unsigned long
ElfAlignOutput(llvm::raw_fd_ostream& os, unsigned int align)
{
    assert(isExp2(align) && "requested alignment not a power of two");

    uint64_t pos = os.tell();
    if (os.has_error())
        throw IOError(N_("could not get file position on output file"));

    unsigned long delta = align - (pos & (align-1));
    if (delta != align)
    {
        pos += delta;
        os.seek(pos);
        if (os.has_error())
            throw IOError(N_("could not set file position on output file"));
    }
    return static_cast<unsigned long>(pos);
}

void
ElfObject::Output(llvm::raw_fd_ostream& os, bool all_syms, Errwarns& errwarns,
                  Diagnostic& diags)
{
    StringTable shstrtab, strtab;

    // Add filename to strtab and set as .file symbol name
    if (m_file_elfsym)
    {
        m_file_elfsym->setName(strtab.getIndex(m_object.getSourceFilename()));
    }

    // Allocate space for Ehdr by seeking forward
    os.seek(m_config.getProgramHeaderSize());
    if (os.has_error())
        throw IOError(N_("could not seek on output file"));

    // Create missing section headers
#if 0
    if (yasm_object_sections_traverse(object, &info,
                                      elf_objfmt_create_dbg_secthead))
        return;
#endif
    // Finalize symbol table, handling any objfmt-specific extensions given
    // during parse phase.  If all_syms is true, add all local symbols and
    // include name information.
    for (Object::symbol_iterator i=m_object.symbols_begin(),
         end=m_object.symbols_end(); i != end; ++i)
    {
        try
        {
            FinalizeSymbol(*i, strtab, all_syms);
        }
        catch (Error& err)
        {
            errwarns.Propagate(i->getDeclSource(), err);
        }
        errwarns.Propagate(i->getDeclSource());
    }

    m_config.secthead_count = 0;

    // dummy section header
    ElfSection null_sect(m_config, SHT_NULL, 0);
    null_sect.setIndex(m_config.secthead_count++);

    ElfOutput out(os, *this, m_object);

    // Output user sections.
    // Assign indices and names as we go (including for relocation sections).
    for (Object::section_iterator i=m_object.sections_begin(),
         end=m_object.sections_end(); i != end; ++i)
    {
        out.OutputSection(*i, &m_config.secthead_count, shstrtab, errwarns);
    }

    // If we're not forcing all symbols to be in the table, go through
    // relocations and force referenced symbols into symbol table, because
    // relocation needs a symtab index.
    if (!all_syms)
    {
        for (Object::section_iterator sect=m_object.sections_begin(),
             endsect=m_object.sections_end(); sect != endsect; ++sect)
        {
            for (Section::reloc_iterator reloc=sect->relocs_begin(),
                 endreloc=sect->relocs_end(); reloc != endreloc; ++reloc)
            {
                SymbolRef sym = reloc->getSymbol();
                ElfSymbol& elfsym = BuildSymbol(*sym); // XXX
                elfsym.setName(strtab.getIndex(sym->getName()));
                setSymbolSectionValue(*sym, elfsym);
            }
        }
    }

    // Partition symbol table to put local symbols first
    stdx::stable_partition(m_object.symbols_begin(), m_object.symbols_end(),
                           isLocal);

    // Number symbols.
    ElfSymbolIndex symtab_nlocal;
    m_config.AssignSymbolIndices(m_object, &symtab_nlocal);

    unsigned long offset, size;
    ElfStringIndex shstrtab_name = shstrtab.getIndex(".shstrtab");
    ElfStringIndex strtab_name = shstrtab.getIndex(".strtab");
    ElfStringIndex symtab_name = shstrtab.getIndex(".symtab");

    // section header string table (.shstrtab)
    offset = ElfAlignOutput(os, 4);
    size = shstrtab.getSize();
    shstrtab.Write(os);

    ElfSection shstrtab_sect(m_config, SHT_STRTAB, 0);
    m_config.shstrtab_index = m_config.secthead_count;
    shstrtab_sect.setName(shstrtab_name);
    shstrtab_sect.setIndex(m_config.secthead_count++);
    shstrtab_sect.setFileOffset(offset);
    shstrtab_sect.setSize(size);

    // string table (.strtab)
    offset = ElfAlignOutput(os, 4);
    size = strtab.getSize();
    strtab.Write(os);

    ElfSection strtab_sect(m_config, SHT_STRTAB, 0);
    strtab_sect.setName(strtab_name);
    strtab_sect.setIndex(m_config.secthead_count++);
    strtab_sect.setFileOffset(offset);
    strtab_sect.setSize(size);

    // symbol table (.symtab)
    offset = ElfAlignOutput(os, 4);
    size = m_config.WriteSymbolTable(os, m_object, errwarns, out.getScratch());

    ElfSection symtab_sect(m_config, SHT_SYMTAB, 0, true);
    symtab_sect.setName(symtab_name);
    symtab_sect.setIndex(m_config.secthead_count++);
    symtab_sect.setFileOffset(offset);
    symtab_sect.setSize(size);
    symtab_sect.setInfo(symtab_nlocal);
    symtab_sect.setLink(strtab_sect.getIndex());    // link to .strtab

    // output relocations
    for (Object::section_iterator i=m_object.sections_begin(),
         end=m_object.sections_end(); i != end; ++i)
    {
        // No relocations to output?  Go on to next section
        if (i->getRelocs().size() == 0)
            continue;

        ElfSection* elfsect = i->getAssocData<ElfSection>();
        assert(elfsect != 0);
        elfsect->WriteRelocs(os, *i, errwarns, out.getScratch(),
                             *m_machine);
    }

    // output section header table
    m_config.secthead_pos = ElfAlignOutput(os, 16);

#if 0
    // stabs debugging support
    if (strcmp(yasm_dbgfmt_keyword(object->dbgfmt), "stabs")==0)
    {
        Section* stabsect = m_object.find_section(".stab");
        Section* stabstrsect = m_object.find_section(".stabstr");
        if (stabsect && stabstrsect)
        {
            ElfSection* stab = get_elf(*stabsect);
            ElfSection* stabstr = get_elf(*stabstrsect);
            assert(stab && stabstr && "missing .stab or .stabstr section/data");
            stab->set_link(stabstr->get_index());
        }
    }
#endif

    // null section header
    null_sect.Write(os, out.getScratch());

    // user section headers (and relocation section headers)
    for (Object::section_iterator i=m_object.sections_begin(),
         end=m_object.sections_end(); i != end; ++i)
    {
        ElfSection* elfsect = i->getAssocData<ElfSection>();
        assert(elfsect != 0);

        if (elfsect->Write(os, out.getScratch()) == 0)
            continue;

        // relocation entries for .foo are stored in section .rel[a].foo
        elfsect->WriteRel(os, symtab_sect.getIndex(), *i, out.getScratch());
    }

    // standard section headers
    shstrtab_sect.Write(os, out.getScratch());
    strtab_sect.Write(os, out.getScratch());
    symtab_sect.Write(os, out.getScratch());

    // output Ehdr
    os.seek(0);
    if (os.has_error())
        throw IOError(N_("could not seek on output file"));

    m_config.WriteProgramHeader(os, out.getScratch());
}

Section*
ElfObject::AddDefaultSection()
{
    Section* section = AppendSection(".text", clang::SourceLocation());
    section->setDefault(true);
    return section;
}

Section*
ElfObject::AppendSection(llvm::StringRef name, clang::SourceLocation source)
{
    ElfSectionType type = SHT_PROGBITS;
    ElfSectionFlags flags = SHF_ALLOC;
    unsigned long align = 4;

    if (name == ".bss")
    {
        type = SHT_NOBITS;
        flags = SHF_ALLOC + SHF_WRITE;
    }
    else if (name == ".data")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_WRITE;
    }
    else if (name == ".tdata")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_WRITE + SHF_TLS;
    }
    else if (name == ".rodata")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC;
    }
    else if (name == ".text")
    {
        align = 16;
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_EXECINSTR;
    }
    else if (name == ".comment")
    {
        align = 0;
        type = SHT_PROGBITS;
        flags = 0;
    }
    else
    {
        // Default to code, but align=1
        align = 1;
    }

    bool code = (flags & SHF_EXECINSTR) != 0;
    bool bss = (type == SHT_NOBITS);

    Section* section = new Section(name, code, bss, source);
    m_object.AppendSection(std::auto_ptr<Section>(section));
    section->setAlign(align);

    // Define a label for the start of the section
    Location start = {&section->bytecodes_first(), 0};
    SymbolRef sym = m_object.getSymbol(name);
    sym->DefineLabel(start, source);

    // Add ELF data to the section
    ElfSection* elfsect = new ElfSection(m_config, type, flags);
    section->AddAssocData(std::auto_ptr<ElfSection>(elfsect));
    elfsect->setSymbol(sym);

    return section;
}

void
ElfObject::DirGasSection(DirectiveInfo& info)
{
    assert(info.isObject(m_object));
    NameValues& nvs = info.getNameValues();

    if (!nvs.front().isString())
        throw Error(N_("section name must be a string"));
    llvm::StringRef sectname = nvs.front().getString();

    Section* sect = m_object.FindSection(sectname);
    bool first = true;
    if (sect)
        first = sect->isDefault();
    else
        sect = AppendSection(sectname, info.getSource());

    m_object.setCurSection(sect);
    sect->setDefault(false);

    // No name/values, so nothing more to do
    if (nvs.size() <= 1)
        return;

    // Section flags must be a string.
    if (!nvs[1].isString())
        throw SyntaxError(N_("flag string expected"));

    // Parse section flags
    ElfSection* elfsect = sect->getAssocData<ElfSection>();
    assert(elfsect != 0);

    int flags = 0, type = SHT_NULL;
    llvm::StringRef flagstr = nvs[1].getString();

    for (size_t i=0; i<flagstr.size(); ++i)
    {
        switch (flagstr[i])
        {
            case 'a':
                flags |= SHF_ALLOC;
                break;
            case 'w':
                flags |= SHF_WRITE;
                break;
            case 'x':
                flags |= SHF_EXECINSTR;
                break;
            case 'M':
                flags |= SHF_MERGE;
                break;
            case 'S':
                flags |= SHF_STRINGS;
                break;
            case 'G':
                flags |= SHF_GROUP;
                break;
            case 'T':
                flags |= SHF_TLS;
                break;
            default:
                setWarn(WARN_GENERAL, String::Compose(
                    N_("unrecognized section attribute: `%1'"), flagstr[i]));
        }
    }

    // Parse section type
    if (nvs.size() > 2 && nvs[2].isId())
    {
        llvm::StringRef typestr = nvs[2].getId();
        if (typestr == "progbits")
            type = SHT_PROGBITS;
        else if (typestr == "nobits")
            type = SHT_NOBITS;
        else if (typestr == "note")
            type = SHT_NOTE;
        else if (typestr == "init_array")
            type = SHT_INIT_ARRAY;
        else if (typestr == "fini_array")
            type = SHT_FINI_ARRAY;
        else if (typestr == "preinit_array")
            type = SHT_PREINIT_ARRAY;
    }

    // Handle merge entity size
    elfsect->setTypeFlags(static_cast<ElfSectionType>(type),
                          static_cast<ElfSectionFlags>(flags));
    sect->setBSS(type == SHT_NOBITS);
    sect->setCode((flags & SHF_EXECINSTR) != 0);
}

void
ElfObject::DirSection(DirectiveInfo& info)
{
    assert(info.isObject(m_object));
    NameValues& nvs = info.getNameValues();
    clang::SourceLocation source = info.getSource();

    if (!nvs.front().isString())
        throw Error(N_("section name must be a string"));
    llvm::StringRef sectname = nvs.front().getString();

    Section* sect = m_object.FindSection(sectname);
    bool first = true;
    if (sect)
        first = sect->isDefault();
    else
        sect = AppendSection(sectname, source);

    m_object.setCurSection(sect);
    sect->setDefault(false);

    // No name/values, so nothing more to do
    if (nvs.size() <= 1)
        return;

    // Ignore flags if we've seen this section before
    if (!first)
    {
        setWarn(WARN_GENERAL,
                N_("section flags ignored on section redeclaration"));
        return;
    }

    // Parse section flags
    ElfSection* elfsect = sect->getAssocData<ElfSection>();
    assert(elfsect != 0);

    IntNum align;
    bool has_align = false;
    IntNum merge;
    bool has_merge = false;

    unsigned long type = elfsect->getType();
    unsigned long flags = elfsect->getFlags();

    DirHelpers helpers;
    static const struct
    {
        const char* enable;
        const char* disable;
        unsigned int flag;
    }
    name_flags[] =
    {
        {"alloc",   "noalloc",  SHF_ALLOC},
        {"exec",    "noexec",   SHF_EXECINSTR},
        {"write",   "nowrite",  SHF_WRITE},
        {"tls",     "notls",    SHF_TLS},
    };
    for (unsigned int i=0; i<NELEMS(name_flags); ++i)
    {
        helpers.Add(name_flags[i].enable, false,
                    BIND::bind(&DirSetFlag, _1, &flags, name_flags[i].flag));
        helpers.Add(name_flags[i].disable, false,
                    BIND::bind(&DirClearFlag, _1, &flags,
                               name_flags[i].flag));
    }

    helpers.Add("noprogbits", false,
                BIND::bind(&DirResetFlag, _1, &type, SHT_NOBITS));
    helpers.Add("nobits", false,
                BIND::bind(&DirResetFlag, _1, &type, SHT_NOBITS));
    helpers.Add("progbits", false,
                BIND::bind(&DirResetFlag, _1, &type, SHT_PROGBITS));

    helpers.Add("align", true, BIND::bind(&DirIntNum, _1, &m_object, source,
                                          &align, &has_align));
    helpers.Add("merge", true, BIND::bind(&DirIntNum, _1, &m_object, source,
                                          &merge, &has_merge));

    helpers(++nvs.begin(), nvs.end(), DirNameValueWarn);

    // handle align
    if (has_align)
    {
        unsigned long aligni = align.getUInt();

        // Alignments must be a power of two.
        if (!isExp2(aligni))
        {
            throw ValueError(String::Compose(
                N_("argument to `%1' is not a power of two"), "align"));
        }

        sect->setAlign(aligni);
    }

    // Handle merge entity size
    if (has_merge)
    {
        flags |= SHF_MERGE;
        elfsect->setEntSize(merge.getUInt());
    }

    elfsect->setTypeFlags(static_cast<ElfSectionType>(type),
                          static_cast<ElfSectionFlags>(flags));
    sect->setBSS(type == SHT_NOBITS);
    sect->setCode((flags & SHF_EXECINSTR) != 0);
}

void
ElfObject::DirType(DirectiveInfo& info)
{
    assert(info.isObject(m_object));
    NameValues& namevals = info.getNameValues();

    SymbolRef sym = info.getObject().getSymbol(namevals.front().getId());
    sym->Use(info.getSource());

    ElfSymbol& elfsym = BuildSymbol(*sym);

    // Pull new type from param
    if (namevals.size() < 2)
        throw SyntaxError(N_("no type specified"));
    if (!namevals[1].isId())
        throw SyntaxError(N_("type must be an identifier"));

    llvm::StringRef type = namevals[1].getId();
    if (type.equals_lower("function"))
        elfsym.setType(STT_FUNC);
    else if (type.equals_lower("object"))
        elfsym.setType(STT_OBJECT);
    else if (type.equals_lower("tls_object"))
        elfsym.setType(STT_TLS);
    else if (type.equals_lower("notype"))
        elfsym.setType(STT_NOTYPE);
    else
        setWarn(WARN_GENERAL,
                String::Compose(N_("unrecognized symbol type `%s'"), type));
}

void
ElfObject::DirSize(DirectiveInfo& info)
{
    assert(info.isObject(m_object));
    NameValues& namevals = info.getNameValues();
    clang::SourceLocation source = info.getSource();

    SymbolRef sym = info.getObject().getSymbol(namevals.front().getId());
    sym->Use(source);

    // Pull new size from param
    if (namevals.size() < 2)
        throw SyntaxError(N_("no size specified"));
    if (!namevals[1].isExpr())
        throw SyntaxError(N_("size must be an expression"));
    Expr size = namevals[1].getExpr(info.getObject(), source);

    ElfSymbol& elfsym = BuildSymbol(*sym);
    elfsym.setSize(size, source);
}

void
ElfObject::DirWeak(DirectiveInfo& info)
{
    assert(info.isObject(m_object));
    NameValues& namevals = info.getNameValues();

    SymbolRef sym = info.getObject().getSymbol(namevals.front().getId());
    sym->Declare(Symbol::GLOBAL, info.getSource());

    ElfSymbol& elfsym = BuildSymbol(*sym);
    elfsym.setBinding(STB_WEAK);
}

void
ElfObject::DirIdent(DirectiveInfo& info)
{
    assert(info.isObject(m_object));
    DirIdentCommon(*this, ".comment", info);
}

std::vector<llvm::StringRef>
ElfObject::getDebugFormatKeywords()
{
    static const char* keywords[] =
    {
        "null",
        "stabs",
        "dwarf2"
    };
    return std::vector<llvm::StringRef>(keywords, keywords+NELEMS(keywords));
}

void
ElfObject::AddDirectives(Directives& dirs, llvm::StringRef parser)
{
    static const Directives::Init<ElfObject> nasm_dirs[] =
    {
        {"section", &ElfObject::DirSection, Directives::ARG_REQUIRED},
        {"segment", &ElfObject::DirSection, Directives::ARG_REQUIRED},
        {"type", &ElfObject::DirType, Directives::ID_REQUIRED},
        {"size", &ElfObject::DirSize, Directives::ID_REQUIRED},
        {"weak", &ElfObject::DirWeak, Directives::ID_REQUIRED},
        {"ident", &ElfObject::DirIdent, Directives::ANY},
    };
    static const Directives::Init<ElfObject> gas_dirs[] =
    {
        {".section", &ElfObject::DirGasSection, Directives::ARG_REQUIRED},
        {".type", &ElfObject::DirType, Directives::ID_REQUIRED},
        {".size", &ElfObject::DirSize, Directives::ID_REQUIRED},
        {".weak", &ElfObject::DirWeak, Directives::ID_REQUIRED},
        {".ident", &ElfObject::DirIdent, Directives::ANY},
    };

    if (parser.equals_lower("nasm"))
        dirs.AddArray(this, nasm_dirs, NELEMS(nasm_dirs));
    else if (parser.equals_lower("gas") || parser.equals_lower("gnu"))
        dirs.AddArray(this, gas_dirs, NELEMS(gas_dirs));
}
#if 0
static const char *elf_nasm_stdmac[] = {
    "%imacro type 1+.nolist",
    "[type %1]",
    "%endmacro",
    "%imacro size 1+.nolist",
    "[size %1]",
    "%endmacro",
    "%imacro weak 1+.nolist",
    "[weak %1]",
    "%endmacro",
    NULL
};

static const yasm_stdmac elf_objfmt_stdmacs[] = {
    { "nasm", "nasm", elf_nasm_stdmac },
    { NULL, NULL, NULL }
};
#endif
void
DoRegister()
{
    RegisterModule<ObjectFormatModule,
                   ObjectFormatModuleImpl<ElfObject> >("elf");
    RegisterModule<ObjectFormatModule,
                   ObjectFormatModuleImpl<Elf32Object> >("elf32");
    RegisterModule<ObjectFormatModule,
                   ObjectFormatModuleImpl<Elf64Object> >("elf64");
}

}}} // namespace yasm::objfmt::elf
