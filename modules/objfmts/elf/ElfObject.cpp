//
// ELF object format
//
//  Copyright (C) 2003-2007  Michael Urman
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND OTHER CONTRIBUTORS ``AS IS''
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR OTHER CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Notes
//
// elf-objfmt uses the "linking" view of an ELF file:
// ELF header, an optional program header table, several sections,
// and a section header table
//
// The ELF header tells us some overall program information,
//   where to find the PHT (if it exists) with phnum and phentsize,
//   and where to find the SHT with shnum and shentsize
//
// The PHT doesn't seem to be generated by NASM for elftest.asm
//
// The SHT
//
// Each Section is spatially disjoint, and has exactly one SHT entry.
//
#include <util.h>

#include <yasmx/Support/bitcount.h>
#include <yasmx/Support/Compose.h>
#include <yasmx/Support/errwarn.h>
#include <yasmx/Support/nocase.h>
#include <yasmx/Support/registry.h>
#include <yasmx/Support/scoped_array.h>
#include <yasmx/Arch.h>
#include <yasmx/BytecodeContainer_util.h>
#include <yasmx/BytecodeOutput.h>
#include <yasmx/Bytecode.h>
#include <yasmx/Directive.h>
#include <yasmx/DirHelpers.h>
#include <yasmx/Errwarns.h>
#include <yasmx/Location_util.h>
#include <yasmx/Object.h>
#include <yasmx/ObjectFormat.h>
#include <yasmx/Object_util.h>
#include <yasmx/NameValue.h>
#include <yasmx/Section.h>
#include <yasmx/StringTable.h>
#include <yasmx/Symbol_util.h>

#include "ElfConfig.h"
#include "ElfMachine.h"
#include "ElfReloc.h"
#include "ElfSection.h"
#include "ElfSymbol.h"
#include "ElfTypes.h"


namespace yasm
{
namespace objfmt
{
namespace elf
{

static inline bool
isLocal(const Symbol& sym)
{
    int vis = sym.getVisibility();
    return (vis == Symbol::LOCAL || (vis & Symbol::DLOCAL) != 0);
}

class ElfObject : public ObjectFormat
{
public:
    ElfObject(const ObjectFormatModule& module,
              Object& object,
              unsigned int bits=0);
    ~ElfObject() {}

    static const char* getName() { return "ELF"; }
    static const char* getKeyword() { return "elf"; }
    static const char* getExtension() { return ".o"; }
    static unsigned int getDefaultX86ModeBits() { return 0; }
    static const char* getDefaultDebugFormatKeyword() { return "null"; }
    static std::vector<const char*> getDebugFormatKeywords();
    static bool isOkObject(Object& object) { return true; }
    static bool Taste(std::istream& is,
                      /*@out@*/ std::string* arch_keyword,
                      /*@out@*/ std::string* machine)
    { return false; }

    void AddDirectives(Directives& dirs, const char* parser);

    void InitSymbols(const char* parser);

    void Read(std::istream& is);
    void Output(std::ostream& os, bool all_syms, Errwarns& errwarns);

    Section* AddDefaultSection();
    Section* AppendSection(const std::string& name, unsigned long line);

    ElfSymbol& BuildSymbol(Symbol& sym);
    void BuildExtern(Symbol& sym);
    void BuildGlobal(Symbol& sym);
    void BuildCommon(Symbol& sym);
    void setSymbolSectionValue(Symbol& sym, ElfSymbol& elfsym);
    void FinalizeSymbol(Symbol& sym, StringTable& strtab, bool local_names);

    void DirGasSection(Object& object,
                       NameValues& namevals,
                       NameValues& objext_namevals,
                       unsigned long line);
    void DirSection(Object& object,
                    NameValues& namevals,
                    NameValues& objext_namevals,
                    unsigned long line);
    void DirType(Object& object,
                 NameValues& namevals,
                 NameValues& objext_namevals,
                 unsigned long line);
    void DirSize(Object& object,
                 NameValues& namevals,
                 NameValues& objext_namevals,
                 unsigned long line);
    void DirWeak(Object& object,
                  NameValues& namevals,
                  NameValues& objext_namevals,
                  unsigned long line);
    void DirIdent(Object& object,
                  NameValues& namevals,
                  NameValues& objext_namevals,
                  unsigned long line);

    ElfConfig m_config;                     // ELF configuration
    util::scoped_ptr<ElfMachine> m_machine; // ELF machine interface

    ElfSymbol* m_file_elfsym;               // .file symbol
    SymbolRef m_dotdotsym;                  // ..sym symbol
};

bool TasteCommon(std::istream& is,
                 /*@out@*/ std::string* arch_keyword,
                 /*@out@*/ std::string* machine,
                 ElfClass cls);

class Elf32Object : public ElfObject
{
public:
    Elf32Object(const ObjectFormatModule& module, Object& object)
        : ElfObject(module, object, 32)
    {}

    static const char* getName() { return "ELF (32-bit)"; }
    static const char* getKeyword() { return "elf32"; }
    static const char* getExtension() { return ElfObject::getExtension(); }
    static unsigned int getDefaultX86ModeBits() { return 32; }

    static const char* getDefaultDebugFormatKeyword()
    { return ElfObject::getDefaultDebugFormatKeyword(); }
    static std::vector<const char*> getDebugFormatKeywords()
    { return ElfObject::getDebugFormatKeywords(); }

    static bool isOkObject(Object& object)
    { return isOkElfMachine(*object.getArch(), ELFCLASS32); }

    // For tasting, let main elf handle it.
    static bool Taste(std::istream& is,
                      /*@out@*/ std::string* arch_keyword,
                      /*@out@*/ std::string* machine)
    { return TasteCommon(is, arch_keyword, machine, ELFCLASS32); }
};

class Elf64Object : public ElfObject
{
public:
    Elf64Object(const ObjectFormatModule& module, Object& object)
        : ElfObject(module, object, 64)
    {}

    static const char* getName() { return "ELF (64-bit)"; }
    static const char* getKeyword() { return "elf64"; }
    static const char* getExtension() { return ElfObject::getExtension(); }
    static unsigned int getDefaultX86ModeBits() { return 64; }

    static const char* getDefaultDebugFormatKeyword()
    { return ElfObject::getDefaultDebugFormatKeyword(); }
    static std::vector<const char*> getDebugFormatKeywords()
    { return ElfObject::getDebugFormatKeywords(); }

    static bool isOkObject(Object& object)
    { return isOkElfMachine(*object.getArch(), ELFCLASS64); }

    // For tasting, let main elf handle it.
    static bool Taste(std::istream& is,
                      /*@out@*/ std::string* arch_keyword,
                      /*@out@*/ std::string* machine)
    { return TasteCommon(is, arch_keyword, machine, ELFCLASS64); }
};

ElfObject::ElfObject(const ObjectFormatModule& module,
                     Object& object,
                     unsigned int bits)
    : ObjectFormat(module, object)
    , m_machine(0)
    , m_file_elfsym(0)
    , m_dotdotsym(0)
{
    if (bits == 32)
        m_config.cls = ELFCLASS32;
    else if (bits == 64)
        m_config.cls = ELFCLASS64;
    else if (bits != 0)
        throw ValueError(String::Compose(N_("unknown ELF bits setting %1"),
                                         bits));

    m_machine.reset(CreateElfMachine(*m_object.getArch(),
                                     m_config.cls).release());
    m_machine->Configure(&m_config);
}

bool
TasteCommon(std::istream& is,
            /*@out@*/ std::string* arch_keyword,
            /*@out@*/ std::string* machine,
            ElfClass cls)
{
    ElfConfig config;

    // Read header
    if (!config.ReadProgramHeader(is))
        return false;

    // Check class
    if (config.cls != cls)
        return false;

    // for now, just handle this here
    switch (config.machine_type)
    {
        case EM_386:
            arch_keyword->assign("x86");
            machine->assign("x86");
            break;
        case EM_X86_64:
            arch_keyword->assign("x86");
            machine->assign("amd64");
            break;
        default:
            return false;
    }
    return true;
}

void
ElfObject::Read(std::istream& is)
{
    // Read header
    if (!m_config.ReadProgramHeader(is))
        throw Error(N_("not an ELF file"));

    // Can't handle files without section table yet
    if (m_config.secthead_pos == 0)
        throw Error(N_("no section table"));

    // Read section string table (needed for section names)
    is.seekg(m_config.secthead_pos +
             m_config.shstrtab_index * m_config.secthead_size);
    if (!is)
        throw Error(N_("could not read .shstrtab section header"));

    std::auto_ptr<ElfSection>
        shstrtab_sect(new ElfSection(m_config, is, m_config.shstrtab_index));

    StringTable shstrtab;
    is.seekg(shstrtab_sect->getFileOffset());
    shstrtab.Read(is, shstrtab_sect->getSize().getUInt());
    if (!is)
        throw Error(N_("could not read .shstrtab string data"));

    // Read all section headers

    // owned storage for "misc" sections (e.g. relocation sections)
    stdx::ptr_vector<ElfSection> misc_sections;
    stdx::ptr_vector_owner<ElfSection> misc_sections_owner(misc_sections);
    misc_sections.reserve(m_config.secthead_count);

    // indexed array of all ElfSections by section index
    util::scoped_array<ElfSection*>
        elfsects(new ElfSection*[m_config.secthead_count]);
    // indexed array of all Sections by section index
    util::scoped_array<Section*>
        sections(new Section*[m_config.secthead_count]);

    // special sections
    ElfSection* strtab_sect = 0;
    ElfSection* symtab_sect = 0;

    // read section headers
    is.seekg(m_config.secthead_pos);
    for (unsigned int i=0; i<m_config.secthead_count; ++i)
    {
        // read section header and save by index
        std::auto_ptr<ElfSection> elfsect(new ElfSection(m_config, is, i));
        elfsects[i] = elfsect.get();

        std::string sectname = shstrtab.getString(elfsect->getName());
        if (sectname == ".strtab")
        {
            strtab_sect = elfsect.get();
        }
        else if (sectname == ".symtab")
        {
            symtab_sect = elfsect.get();
        }

        ElfSectionType secttype = elfsect->getType();
        if (secttype == SHT_NULL ||
            secttype == SHT_SYMTAB ||
            secttype == SHT_STRTAB ||
            secttype == SHT_RELA ||
            secttype == SHT_REL)
        {
            misc_sections.push_back(elfsect.release());
            sections[i] = 0;

            // try to pick these up by section type if not set
            if (secttype == SHT_SYMTAB && symtab_sect == 0)
                symtab_sect = elfsect.get();
            else if (secttype == SHT_STRTAB && strtab_sect == 0)
                strtab_sect = elfsect.get();

            // if any section is RELA, set config to RELA
            if (secttype == SHT_RELA)
                m_config.rela = true;
        }
        else
        {
            std::auto_ptr<Section> section = elfsect->CreateSection(shstrtab);
            elfsect->LoadSectionData(*section, is);
            sections[i] = section.get();

            // Associate section data with section
            section->AddAssocData(ElfSection::key,
                std::auto_ptr<AssocData>(elfsect.release()));

            // Add section to object
            m_object.AppendSection(section);
        }
    }

    // Symbol table by index (needed for relocation lookups by index)
    std::vector<SymbolRef> symtab;

    // read symtab string table and symbol table (if present)
    if (symtab_sect != 0)
    {
        // get string table section index from symtab link field if reasonable
        ElfSectionIndex link = symtab_sect->getLink();
        if (link < m_config.secthead_count &&
            elfsects[link]->getType() == SHT_STRTAB)
            strtab_sect = elfsects[link];

        if (strtab_sect == 0)
            throw Error(N_("could not find symbol string table"));

        // load symbol string table
        StringTable strtab;
        is.seekg(strtab_sect->getFileOffset());
        strtab.Read(is, strtab_sect->getSize().getUInt());
        if (!is)
            throw Error(N_("could not read symbol string data"));

        // load symbol table
        unsigned long symtab_size = symtab_sect->getSize().getUInt();
        ElfSize symsize = symtab_sect->getEntSize();
        if (symsize == 0)
            throw Error(N_("symbol table entity size is zero"));
        is.seekg(symtab_sect->getFileOffset());
        if (!m_config.ReadSymbolTable(is, symtab, m_object, symtab_size,
                                      symsize, strtab, &sections[0]))
            throw Error(N_("could not read symbol table"));
    }

    // go through misc sections to load relocations
    for (unsigned int i=0; i<m_config.secthead_count; ++i)
    {
        ElfSection* reloc_sect = elfsects[i];
        ElfSectionType secttype = reloc_sect->getType();
        if (secttype != SHT_REL && secttype != SHT_RELA)
            continue;

        // get symbol table section index from link field (if valid)
        ElfSection* rel_symtab_sect = symtab_sect;
        ElfSectionIndex link = reloc_sect->getLink();
        if (link < m_config.secthead_count &&
            elfsects[link]->getType() == SHT_SYMTAB)
        {
            if (rel_symtab_sect != elfsects[link])
            {
                throw Error(N_("only one symbol table supported"));
            }
        }

        // section relocs apply to is indicated by info field
        ElfSectionIndex info = reloc_sect->getInfo();
        if (link >= m_config.secthead_count || sections[info] == 0)
            continue;

        // load relocations
        is.seekg(reloc_sect->getFileOffset());
        unsigned long relocs_size = reloc_sect->getSize().getUInt();
        if (!elfsects[info]->ReadRelocs(is, *sections[info], relocs_size,
                                        *m_machine, symtab,
                                        secttype == SHT_RELA))
            throw Error(String::Compose(
                N_("could not read section `%1' relocations"),
                sections[info]->getName()));
    }
}

void
ElfObject::InitSymbols(const char* parser)
{
    // Add .file symbol
    SymbolRef filesym = m_object.AppendSymbol(".file");
    filesym->DefineSpecial(Symbol::LOCAL);

    std::auto_ptr<ElfSymbol> elfsym(new ElfSymbol());
    elfsym->setSectionIndex(SHN_ABS);
    elfsym->setBinding(STB_LOCAL);
    elfsym->setType(STT_FILE);
    m_file_elfsym = elfsym.get();

    filesym->AddAssocData(ElfSymbol::key,
                          std::auto_ptr<AssocData>(elfsym.release()));

    // Create ..sym special symbol (NASM only)
    if (String::NocaseEqual(parser, "nasm"))
    {
        m_dotdotsym = m_object.AddSpecialSymbol("sym");
        m_dotdotsym->DefineSpecial(Symbol::EXTERN);
    }

    // Create machine-specific special symbols
    m_machine->AddSpecialSymbols(m_object, parser);
}

ElfSymbol&
ElfObject::BuildSymbol(Symbol& sym)
{
    ElfSymbol* elfsym = getElf(sym);

    if (!elfsym)
    {
        elfsym = new ElfSymbol;
        sym.AddAssocData(ElfSymbol::key, std::auto_ptr<AssocData>(elfsym));
    }

    return *elfsym;
}

void
ElfObject::BuildExtern(Symbol& sym)
{
    const NameValues* objext_nvs = getObjextNameValues(sym);

    if (objext_nvs)
    {
        for (NameValues::const_iterator nv=objext_nvs->begin(),
             end=objext_nvs->end(); nv != end; ++nv)
        {
            if (nv->isString())
            {
                throw TypeError(String::Compose(
                    N_("unrecognized symbol type `%1'"), nv->getString()));
            }
        }
    }

    ElfSymbol& elfsym = BuildSymbol(sym);
    elfsym.setBinding(STB_GLOBAL);
}

static bool
GlobalNameValueFallback(NameValue& nv, Object* object, unsigned long line,
                        Expr::Ptr* size)

{
    if (!nv.isExpr() && nv.isId())
    {
        throw TypeError(String::Compose(N_("unrecognized symbol type `%s'"),
                                        nv.getId()));
    }
    else if (nv.isExpr() && size->get() == 0)
    {
        *size = nv.ReleaseExpr(*object, line);
        return true;
    }
    else
        return DirNameValueWarn(nv);
}

static inline void
GlobalSetVis(NameValue& nv, ElfSymbolVis* vis_out, unsigned int* vis_count,
             ElfSymbolVis vis)
{
    *vis_out = vis;
    *vis_count = *vis_count + 1;
}


void
ElfObject::BuildGlobal(Symbol& sym)
{
    Expr::Ptr size(0);
    unsigned long type = STT_NOTYPE;    // ElfSymbolType
    ElfSymbolVis vis = STV_DEFAULT;
    unsigned int nvis = 0;

    DirHelpers helpers;

    helpers.Add("function", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_FUNC));
    helpers.Add("data", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_OBJECT));
    helpers.Add("object", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_OBJECT));
    helpers.Add("object", false,
                BIND::bind(&DirResetFlag, _1, &type, STT_OBJECT));
    helpers.Add("internal", false,
                BIND::bind(&GlobalSetVis, _1, &vis, &nvis, STV_INTERNAL));
    helpers.Add("hidden", false,
                BIND::bind(&GlobalSetVis, _1, &vis, &nvis, STV_HIDDEN));
    helpers.Add("protected", false,
                BIND::bind(&GlobalSetVis, _1, &vis, &nvis, STV_PROTECTED));

    NameValues* objext_nvs = getObjextNameValues(sym);
    if (objext_nvs)
    {
        helpers(objext_nvs->begin(), objext_nvs->end(),
                BIND::bind(&GlobalNameValueFallback, _1, &m_object,
                           sym.getDeclLine(), &size));
    }

    if (nvis > 1)
    {
        setWarn(WARN_GENERAL,
            N_("More than one symbol visibility provided; using last"));
    }

    ElfSymbol& elfsym = BuildSymbol(sym);
    elfsym.setBinding(STB_GLOBAL);
    elfsym.setType(static_cast<ElfSymbolType>(type));
    elfsym.setVisibility(vis);
    if (size.get() != 0)
        elfsym.setSize(*size, sym.getDeclLine());
}

void
ElfObject::BuildCommon(Symbol& sym)
{
    NameValues* objext_nvs = getObjextNameValues(sym);
    unsigned long addralign = 0;

    if (objext_nvs)
    {
        for (NameValues::iterator nv=objext_nvs->begin(),
             end=objext_nvs->end(); nv != end; ++nv)
        {
            if (!nv->getName().empty())
            {
                setWarn(WARN_GENERAL, String::Compose(
                    N_("Unrecognized qualifier `%1'"), nv->getName()));
                continue;
            }

            if (!nv->isExpr())
                throw ValueError(N_("alignment constraint is not an integer"));

            std::auto_ptr<Expr> align_expr =
                nv->ReleaseExpr(m_object, sym.getDeclLine());
            if (!align_expr->isIntNum())
                throw ValueError(N_("alignment constraint is not an integer"));
            addralign = align_expr->getIntNum().getUInt();

            // Alignments must be a power of two.
            if (!isExp2(addralign))
            {
                throw ValueError(
                    N_("alignment constraint is not a power of two"));
            }
        }
    }

    ElfSymbol& elfsym = BuildSymbol(sym);
    elfsym.setSectionIndex(SHN_COMMON);
    elfsym.setBinding(STB_GLOBAL);
    elfsym.setSize(*getCommonSize(sym), sym.getDeclLine());
    elfsym.setValue(addralign);
}

void
ElfObject::setSymbolSectionValue(Symbol& sym, ElfSymbol& elfsym)
{
    Location loc;
    if (!sym.getLabel(&loc))
        return;

    if (loc.bc)
    {
        elfsym.setSection(loc.bc->getContainer()->AsSection());
        elfsym.setValue(loc.getOffset());
    }
}

void
ElfObject::FinalizeSymbol(Symbol& sym, StringTable& strtab, bool local_names)
{
    int vis = sym.getVisibility();
    int status = sym.getStatus();
    ElfSymbol* elfsym = getElf(sym);

    if (vis & Symbol::EXTERN)
    {
        BuildExtern(sym);
        elfsym = getElf(sym);
        elfsym->setName(strtab.getIndex(sym.getName()));
        return;
    }

    if (vis & Symbol::COMMON)
    {
        BuildCommon(sym);
        elfsym = getElf(sym);
        elfsym->setName(strtab.getIndex(sym.getName()));
        // fall through (check below catches undefined case)
    }

    // Ignore any undefined at this point.
    if (!(status & Symbol::DEFINED))
        return;

    if (elfsym)
        ;
    else if (vis & Symbol::GLOBAL)
    {
        BuildGlobal(sym);
        elfsym = getElf(sym);
        elfsym->setName(strtab.getIndex(sym.getName()));
    }
    else
    {
        Location loc = {0, 0};
        if (!sym.getLabel(&loc))
        {
            if (!sym.getEqu() && !sym.isAbsoluteSymbol())
                return;
        }

        Section* sect = 0;
        if (loc.bc)
            sect = loc.bc->getContainer()->AsSection();

        // Locals (except when debugging) do not need to be
        // in the symbol table, unless they're a section.
        bool is_sect = false;
        if (sect)
        {
            ElfSection* elfsect = getElf(*sect);
            if (elfsect && elfsect->getSymbol() == &sym)
                is_sect = true;
        }

        if (!local_names && !is_sect)
            return;

        if (sym.getEqu() && !sym.isAbsoluteSymbol())
            return;

        elfsym = &BuildSymbol(sym);
        if (local_names || is_sect)
            elfsym->setName(strtab.getIndex(sym.getName()));
        if (is_sect)
            elfsym->setType(STT_SECTION);
    }

    setSymbolSectionValue(sym, *elfsym);
}

class ElfOutput : public BytecodeStreamOutput
{
public:
    ElfOutput(std::ostream& os, ElfObject& objfmt, Object& object);
    ~ElfOutput();

    void OutputSection(Section& sect,
                       unsigned int* sindex,
                       StringTable& shstrtab,
                       Errwarns& errwarns);

    // OutputBytecode overrides
    void ConvertValueToBytes(Value& value,
                             Bytes& bytes,
                             Location loc,
                             int warn);
    void ConvertSymbolToBytes(SymbolRef sym,
                              Bytes& bytes,
                              Location loc,
                              unsigned int valsize,
                              int warn);

private:
    ElfObject& m_objfmt;
    Object& m_object;
    BytecodeNoOutput m_no_output;
};

ElfOutput::ElfOutput(std::ostream& os, ElfObject& objfmt, Object& object)
    : BytecodeStreamOutput(os)
    , m_objfmt(objfmt)
    , m_object(object)
{
}

ElfOutput::~ElfOutput()
{
}

void
ElfOutput::ConvertSymbolToBytes(SymbolRef sym,
                                Bytes& bytes,
                                Location loc,
                                unsigned int valsize,
                                int warn)
{
    std::auto_ptr<ElfReloc> reloc =
        m_objfmt.m_machine->MakeReloc(sym, SymbolRef(0), loc.getOffset(),
                                      false, valsize);

    // allocate .rel[a] sections on a need-basis
    Section* sect = loc.bc->getContainer()->AsSection();
    sect->AddReloc(std::auto_ptr<Reloc>(reloc.release()));

    m_object.getArch()->ToBytes(0, bytes, valsize, 0, warn);
}

void
ElfOutput::ConvertValueToBytes(Value& value,
                               Bytes& bytes,
                               Location loc,
                               int warn)
{
    if (Expr* e = value.getAbs())
        SimplifyCalcDist(*e);

    // Try to output constant and PC-relative section-local first.
    // Note this does NOT output any value with a SEG, WRT, external,
    // cross-section, or non-PC-relative reference (those are handled below).
    if (value.OutputBasic(bytes, warn, *m_object.getArch()))
        return;

    // Handle other expressions, with relocation if necessary
    if (value.isSegOf() || value.isSectionRelative() || value.getRShift() > 0)
        throw TooComplexError(N_("elf: relocation too complex"));

    IntNum intn(0);
    ElfReloc* reloc = 0;
    if (value.isRelative())
    {
        SymbolRef sym = value.getRelative();
        SymbolRef wrt = value.getWRT();

        if (wrt == m_objfmt.m_dotdotsym)
            wrt = SymbolRef(0);
        else if (wrt && isWRTSymRelative(*wrt))
            ;
        else if (wrt && isWRTPosAdjusted(*wrt))
            intn = loc.getOffset();
        else if (isLocal(*sym))
        {
            // Local symbols need relocation to their section's start, and
            // add in the offset of the bytecode (within the target section)
            // into the abs portion.
            //
            // This is only done if the symbol is relocated against the
            // section instead of the symbol itself.
            Location symloc;
            if (sym->getLabel(&symloc))
            {
                // Relocate to section start
                Section* sym_sect = symloc.bc->getContainer()->AsSection();
                ElfSection* elfsect = getElf(*sym_sect);
                assert(elfsect != 0);
                sym = elfsect->getSymbol();

                intn = symloc.getOffset();
            }
        }

        bool pc_rel = false;
        IntNum intn2;
        if (value.CalcPCRelSub(&intn2, loc))
        {
            // Create PC-relative relocation type and fix up absolute portion.
            pc_rel = true;
            intn += intn2;
        }
        else if (value.hasSubRelative())
            throw TooComplexError(N_("elf: relocation too complex"));

        // Create relocation
        Section* sect = loc.bc->getContainer()->AsSection();
        std::auto_ptr<ElfReloc> reloc_auto =
            m_objfmt.m_machine->MakeReloc(sym, wrt, loc.getOffset(), pc_rel,
                                          value.getSize());
        reloc = reloc_auto.get();
        sect->AddReloc(std::auto_ptr<Reloc>(reloc_auto.release()));
    }

    if (Expr* abs = value.getAbs())
    {
        if (!abs->isIntNum())
            throw TooComplexError(N_("elf: relocation too complex"));
        intn += abs->getIntNum();
    }

    if (reloc)
        reloc->HandleAddend(&intn, m_objfmt.m_config);
    m_object.getArch()->ToBytes(intn, bytes, value.getSize(), 0, warn);
}
#if 0
static int
elf_objfmt_create_dbg_secthead(yasm_section *sect, /*@null@*/ void *d)
{
    /*@null@*/ elf_objfmt_output_info *info = (elf_objfmt_output_info *)d;
    elf_secthead *shead;
    elf_section_type type=SHT_PROGBITS;
    elf_size entsize=0;
    const char *sectname;
    /*@dependent@*/ yasm_symrec *sym;
    elf_strtab_entry *name;

    shead = yasm_section_get_data(sect, &elf_section_data);
    if (shead)
        return 0;   /* only create new secthead if missing */

    sectname = yasm_section_get_name(sect);
    name = elf_strtab_append_str(info->objfmt_elf->shstrtab, sectname);

    if (yasm__strcasecmp(sectname, ".stab")==0) {
        entsize = 12;
    } else if (yasm__strcasecmp(sectname, ".stabstr")==0) {
        type = SHT_STRTAB;
    } else if (yasm__strncasecmp(sectname, ".debug_", 7)==0) {
        ;
    } else
        yasm_internal_error(N_("Unrecognized section without data"));

    shead = elf_secthead_create(name, type, 0, 0, 0);
    elf_secthead_set_entsize(shead, entsize);

    sym = yasm_symtab_define_label(info->object->symtab, sectname,
                                   yasm_section_bcs_first(sect), 1, 0);
    elf_secthead_set_sym(shead, sym);

    yasm_section_add_data(sect, &elf_section_data, shead);

    return 0;
}
#endif
void
ElfOutput::OutputSection(Section& sect,
                         unsigned int* sindex,
                         StringTable& shstrtab,
                         Errwarns& errwarns)
{
    BytecodeOutput* outputter = this;

    ElfSection* elfsect = getElf(sect);
    assert(elfsect != 0);

    if (elfsect->getAlign() == 0)
        elfsect->setAlign(sect.getAlign());

    elfsect->setName(shstrtab.getIndex(sect.getName()));
    elfsect->setIndex(*sindex);
    *sindex = *sindex + 1;

    std::streampos pos;
    if (sect.isBSS())
    {
        // Don't output BSS sections.
        outputter = &m_no_output;
        pos = 0;    // position = 0 because it's not in the file
    }
    else
    {
        pos = m_os.tellp();
        if (pos < 0)
            throw IOError(N_("couldn't read position on output stream"));

        if (sect.bytecodes_last().getNextOffset() == 0)
            return;

        m_os.seekp(elfsect->setFileOffset(pos));
        if (!m_os)
            throw IOError(N_("couldn't seek on output stream"));
    }

    // Output bytecodes
    for (Section::bc_iterator i=sect.bytecodes_begin(),
         end=sect.bytecodes_end(); i != end; ++i)
    {
        try
        {
            i->Output(*outputter);
            elfsect->AddSize(i->getTotalLen());
        }
        catch (Error& err)
        {
            errwarns.Propagate(i->getLine(), err);
        }
        errwarns.Propagate(i->getLine());   // propagate warnings
    }

    if (errwarns.getNumErrors() > 0)
        return;

    // Sanity check final section size
    assert(elfsect->getSize() == sect.bytecodes_last().getNextOffset());

    // Empty?  Go on to next section
    if (elfsect->isEmpty())
        return;

    // No relocations?  Go on to next section
    if (sect.getRelocs().size() == 0)
        return;

    // need relocation section; set it up
    elfsect->setRelIndex(*sindex);
    *sindex = *sindex + 1;

    // name the relocation section .rel[a].foo
    std::string relname = m_objfmt.m_config.getRelocSectionName(sect.getName());
    elfsect->setRelName(shstrtab.getIndex(relname));
}

unsigned long
ElfAlignOutput(std::ostream& os, unsigned int align)
{
    assert(isExp2(align) && "requested alignment not a power of two");

    std::streampos pos = os.tellp();
    if (pos < 0)
        throw IOError(N_("could not get file position on output file"));

    unsigned long delta = align - (pos & (align-1));
    if (delta != align)
    {
        pos += delta;
        os.seekp(pos);
        if (!os)
            throw IOError(N_("could not set file position on output file"));
    }
    return static_cast<unsigned long>(pos);
}

void
ElfObject::Output(std::ostream& os, bool all_syms, Errwarns& errwarns)
{
    StringTable shstrtab, strtab;

    // Add filename to strtab and set as .file symbol name
    if (m_file_elfsym)
    {
        m_file_elfsym->setName(strtab.getIndex(m_object.getSourceFilename()));
    }

    // Allocate space for Ehdr by seeking forward
    os.seekp(m_config.getProgramHeaderSize());
    if (!os)
        throw IOError(N_("could not seek on output file"));

    // Create missing section headers
#if 0
    if (yasm_object_sections_traverse(object, &info,
                                      elf_objfmt_create_dbg_secthead))
        return;
#endif
    // Finalize symbol table, handling any objfmt-specific extensions given
    // during parse phase.  If all_syms is true, add all local symbols and
    // include name information.
    for (Object::symbol_iterator i=m_object.symbols_begin(),
         end=m_object.symbols_end(); i != end; ++i)
    {
        try
        {
            FinalizeSymbol(*i, strtab, all_syms);
        }
        catch (Error& err)
        {
            errwarns.Propagate(i->getDeclLine(), err);
        }
        errwarns.Propagate(i->getDeclLine());
    }

    m_config.secthead_count = 0;

    // dummy section header
    ElfSection null_sect(m_config, SHT_NULL, 0);
    null_sect.setIndex(m_config.secthead_count++);

    ElfOutput out(os, *this, m_object);

    // Output user sections.
    // Assign indices and names as we go (including for relocation sections).
    for (Object::section_iterator i=m_object.sections_begin(),
         end=m_object.sections_end(); i != end; ++i)
    {
        out.OutputSection(*i, &m_config.secthead_count, shstrtab, errwarns);
    }

    // If we're not forcing all symbols to be in the table, go through
    // relocations and force referenced symbols into symbol table, because
    // relocation needs a symtab index.
    if (!all_syms)
    {
        for (Object::section_iterator sect=m_object.sections_begin(),
             endsect=m_object.sections_end(); sect != endsect; ++sect)
        {
            for (Section::reloc_iterator reloc=sect->relocs_begin(),
                 endreloc=sect->relocs_end(); reloc != endreloc; ++reloc)
            {
                SymbolRef sym = reloc->getSymbol();
                ElfSymbol& elfsym = BuildSymbol(*sym); // XXX
                elfsym.setName(strtab.getIndex(sym->getName()));
                setSymbolSectionValue(*sym, elfsym);
            }
        }
    }

    // Partition symbol table to put local symbols first
    stdx::stable_partition(m_object.symbols_begin(), m_object.symbols_end(),
                           isLocal);

    // Number symbols.
    ElfSymbolIndex symtab_nlocal;
    m_config.AssignSymbolIndices(m_object, &symtab_nlocal);

    unsigned long offset, size;
    ElfStringIndex shstrtab_name = shstrtab.getIndex(".shstrtab");
    ElfStringIndex strtab_name = shstrtab.getIndex(".strtab");
    ElfStringIndex symtab_name = shstrtab.getIndex(".symtab");

    // section header string table (.shstrtab)
    offset = ElfAlignOutput(os, 4);
    size = shstrtab.getSize();
    shstrtab.Write(os);

    ElfSection shstrtab_sect(m_config, SHT_STRTAB, 0);
    m_config.shstrtab_index = m_config.secthead_count;
    shstrtab_sect.setName(shstrtab_name);
    shstrtab_sect.setIndex(m_config.secthead_count++);
    shstrtab_sect.setFileOffset(offset);
    shstrtab_sect.setSize(size);

    // string table (.strtab)
    offset = ElfAlignOutput(os, 4);
    size = strtab.getSize();
    strtab.Write(os);

    ElfSection strtab_sect(m_config, SHT_STRTAB, 0);
    strtab_sect.setName(strtab_name);
    strtab_sect.setIndex(m_config.secthead_count++);
    strtab_sect.setFileOffset(offset);
    strtab_sect.setSize(size);

    // symbol table (.symtab)
    offset = ElfAlignOutput(os, 4);
    size = m_config.WriteSymbolTable(os, m_object, errwarns, out.getScratch());

    ElfSection symtab_sect(m_config, SHT_SYMTAB, 0, true);
    symtab_sect.setName(symtab_name);
    symtab_sect.setIndex(m_config.secthead_count++);
    symtab_sect.setFileOffset(offset);
    symtab_sect.setSize(size);
    symtab_sect.setInfo(symtab_nlocal);
    symtab_sect.setLink(strtab_sect.getIndex());    // link to .strtab

    // output relocations
    for (Object::section_iterator i=m_object.sections_begin(),
         end=m_object.sections_end(); i != end; ++i)
    {
        // No relocations to output?  Go on to next section
        if (i->getRelocs().size() == 0)
            continue;

        ElfSection* elfsect = getElf(*i);
        assert(elfsect != 0);
        elfsect->WriteRelocs(os, *i, errwarns, out.getScratch(),
                             *m_machine);
    }

    // output section header table
    m_config.secthead_pos = ElfAlignOutput(os, 16);

#if 0
    // stabs debugging support
    if (strcmp(yasm_dbgfmt_keyword(object->dbgfmt), "stabs")==0)
    {
        Section* stabsect = m_object.find_section(".stab");
        Section* stabstrsect = m_object.find_section(".stabstr");
        if (stabsect && stabstrsect)
        {
            ElfSection* stab = get_elf(*stabsect);
            ElfSection* stabstr = get_elf(*stabstrsect);
            assert(stab && stabstr && "missing .stab or .stabstr section/data");
            stab->set_link(stabstr->get_index());
        }
    }
#endif

    // null section header
    null_sect.Write(os, out.getScratch());

    // user section headers (and relocation section headers)
    for (Object::section_iterator i=m_object.sections_begin(),
         end=m_object.sections_end(); i != end; ++i)
    {
        ElfSection* elfsect = getElf(*i);
        assert(elfsect != 0);

        if (elfsect->Write(os, out.getScratch()) == 0)
            continue;

        // relocation entries for .foo are stored in section .rel[a].foo
        elfsect->WriteRel(os, symtab_sect.getIndex(), *i, out.getScratch());
    }

    // standard section headers
    shstrtab_sect.Write(os, out.getScratch());
    strtab_sect.Write(os, out.getScratch());
    symtab_sect.Write(os, out.getScratch());

    // output Ehdr
    os.seekp(0);
    if (!os)
        throw IOError(N_("could not seek on output file"));

    m_config.WriteProgramHeader(os, out.getScratch());
}

Section*
ElfObject::AddDefaultSection()
{
    Section* section = AppendSection(".text", 0);
    section->setDefault(true);
    return section;
}

Section*
ElfObject::AppendSection(const std::string& name, unsigned long line)
{
    ElfSectionType type = SHT_PROGBITS;
    ElfSectionFlags flags = SHF_ALLOC;
    unsigned long align = 4;

    if (name == ".bss")
    {
        type = SHT_NOBITS;
        flags = SHF_ALLOC + SHF_WRITE;
    }
    else if (name == ".data")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_WRITE;
    }
    else if (name == ".tdata")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_WRITE + SHF_TLS;
    }
    else if (name == ".rodata")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC;
    }
    else if (name == ".text")
    {
        align = 16;
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_EXECINSTR;
    }
    else if (name == ".comment")
    {
        align = 0;
        type = SHT_PROGBITS;
        flags = 0;
    }
    else
    {
        // Default to code, but align=1
        align = 1;
    }

    bool code = (flags & SHF_EXECINSTR) != 0;
    bool bss = (type == SHT_NOBITS);

    Section* section = new Section(name, code, bss, line);
    m_object.AppendSection(std::auto_ptr<Section>(section));
    section->setAlign(align);

    // Define a label for the start of the section
    Location start = {&section->bytecodes_first(), 0};
    SymbolRef sym = m_object.getSymbol(name);
    sym->DefineLabel(start, line);

    // Add ELF data to the section
    ElfSection* elfsect = new ElfSection(m_config, type, flags);
    section->AddAssocData(ElfSection::key, std::auto_ptr<AssocData>(elfsect));
    elfsect->setSymbol(sym);

    return section;
}

void
ElfObject::DirGasSection(Object& object,
                         NameValues& nvs,
                         NameValues& objext_nvs,
                         unsigned long line)
{
    assert(&object == &m_object);

    if (!nvs.front().isString())
        throw Error(N_("section name must be a string"));
    std::string sectname = nvs.front().getString();

    Section* sect = m_object.FindSection(sectname);
    bool first = true;
    if (sect)
        first = sect->isDefault();
    else
        sect = AppendSection(sectname, line);

    m_object.setCurSection(sect);
    sect->setDefault(false);

    // No name/values, so nothing more to do
    if (nvs.size() <= 1)
        return;

    // Section flags must be a string.
    if (!nvs[1].isString())
        throw SyntaxError(N_("flag string expected"));

    // Parse section flags
    ElfSection* elfsect = getElf(*sect);
    assert(elfsect != 0);

    int flags = 0, type = SHT_NULL;
    std::string flagstr = nvs[1].getString();

    for (std::string::size_type i=0; i<flagstr.length(); ++i)
    {
        switch (flagstr[i])
        {
            case 'a':
                flags |= SHF_ALLOC;
                break;
            case 'w':
                flags |= SHF_WRITE;
                break;
            case 'x':
                flags |= SHF_EXECINSTR;
                break;
            case 'M':
                flags |= SHF_MERGE;
                break;
            case 'S':
                flags |= SHF_STRINGS;
                break;
            case 'G':
                flags |= SHF_GROUP;
                break;
            case 'T':
                flags |= SHF_TLS;
                break;
            default:
                setWarn(WARN_GENERAL, String::Compose(
                    N_("unrecognized section attribute: `%1'"), flagstr[i]));
        }
    }

    // Parse section type
    if (nvs.size() > 2 && nvs[2].isId())
    {
        std::string typestr = nvs[2].getId();
        if (typestr == "progbits")
            type = SHT_PROGBITS;
        else if (typestr == "nobits")
            type = SHT_NOBITS;
        else if (typestr == "note")
            type = SHT_NOTE;
        else if (typestr == "init_array")
            type = SHT_INIT_ARRAY;
        else if (typestr == "fini_array")
            type = SHT_FINI_ARRAY;
        else if (typestr == "preinit_array")
            type = SHT_PREINIT_ARRAY;
    }

    // Handle merge entity size
    elfsect->setTypeFlags(static_cast<ElfSectionType>(type),
                          static_cast<ElfSectionFlags>(flags));
    sect->setBSS(type == SHT_NOBITS);
    sect->setCode((flags & SHF_EXECINSTR) != 0);
}

void
ElfObject::DirSection(Object& object,
                      NameValues& nvs,
                      NameValues& objext_nvs,
                      unsigned long line)
{
    assert(&object == &m_object);

    if (!nvs.front().isString())
        throw Error(N_("section name must be a string"));
    std::string sectname = nvs.front().getString();

    Section* sect = m_object.FindSection(sectname);
    bool first = true;
    if (sect)
        first = sect->isDefault();
    else
        sect = AppendSection(sectname, line);

    m_object.setCurSection(sect);
    sect->setDefault(false);

    // No name/values, so nothing more to do
    if (nvs.size() <= 1)
        return;

    // Ignore flags if we've seen this section before
    if (!first)
    {
        setWarn(WARN_GENERAL,
                N_("section flags ignored on section redeclaration"));
        return;
    }

    // Parse section flags
    ElfSection* elfsect = getElf(*sect);
    assert(elfsect != 0);

    IntNum align;
    bool has_align = false;
    IntNum merge;
    bool has_merge = false;

    unsigned long type = elfsect->getType();
    unsigned long flags = elfsect->getFlags();

    DirHelpers helpers;
    static const struct
    {
        const char* enable;
        const char* disable;
        unsigned int flag;
    }
    name_flags[] =
    {
        {"alloc",   "noalloc",  SHF_ALLOC},
        {"exec",    "noexec",   SHF_EXECINSTR},
        {"write",   "nowrite",  SHF_WRITE},
        {"tls",     "notls",    SHF_TLS},
    };
    for (unsigned int i=0; i<NELEMS(name_flags); ++i)
    {
        helpers.Add(name_flags[i].enable, false,
                    BIND::bind(&DirSetFlag, _1, &flags, name_flags[i].flag));
        helpers.Add(name_flags[i].disable, false,
                    BIND::bind(&DirClearFlag, _1, &flags,
                               name_flags[i].flag));
    }

    helpers.Add("noprogbits", false,
                BIND::bind(&DirResetFlag, _1, &type, SHT_NOBITS));
    helpers.Add("nobits", false,
                BIND::bind(&DirResetFlag, _1, &type, SHT_NOBITS));
    helpers.Add("progbits", false,
                BIND::bind(&DirResetFlag, _1, &type, SHT_PROGBITS));

    helpers.Add("align", true, BIND::bind(&DirIntNum, _1, &m_object, line,
                                          &align, &has_align));
    helpers.Add("merge", true, BIND::bind(&DirIntNum, _1, &m_object, line,
                                          &merge, &has_merge));

    helpers(++nvs.begin(), nvs.end(), DirNameValueWarn);

    // handle align
    if (has_align)
    {
        unsigned long aligni = align.getUInt();

        // Alignments must be a power of two.
        if (!isExp2(aligni))
        {
            throw ValueError(String::Compose(
                N_("argument to `%1' is not a power of two"), "align"));
        }

        sect->setAlign(aligni);
    }

    // Handle merge entity size
    if (has_merge)
    {
        flags |= SHF_MERGE;
        elfsect->setEntSize(merge.getUInt());
    }

    elfsect->setTypeFlags(static_cast<ElfSectionType>(type),
                          static_cast<ElfSectionFlags>(flags));
    sect->setBSS(type == SHT_NOBITS);
    sect->setCode((flags & SHF_EXECINSTR) != 0);
}

void
ElfObject::DirType(Object& object,
                   NameValues& namevals,
                   NameValues& objext_namevals,
                   unsigned long line)
{
    assert(&m_object == &object);

    SymbolRef sym = object.getSymbol(namevals.front().getId());
    sym->Use(line);

    ElfSymbol& elfsym = BuildSymbol(*sym);

    // Pull new type from param
    if (namevals.size() < 2)
        throw SyntaxError(N_("no type specified"));
    if (!namevals[1].isId())
        throw SyntaxError(N_("type must be an identifier"));

    std::string type = namevals[1].getId();
    if (String::NocaseEqual(type, "function"))
        elfsym.setType(STT_FUNC);
    else if (String::NocaseEqual(type, "object"))
        elfsym.setType(STT_OBJECT);
    else if (String::NocaseEqual(type, "tls_object"))
        elfsym.setType(STT_TLS);
    else if (String::NocaseEqual(type, "notype"))
        elfsym.setType(STT_NOTYPE);
    else
        setWarn(WARN_GENERAL,
                String::Compose(N_("unrecognized symbol type `%s'"), type));
}

void
ElfObject::DirSize(Object& object,
                   NameValues& namevals,
                   NameValues& objext_namevals,
                   unsigned long line)
{
    assert(&m_object == &object);

    SymbolRef sym = object.getSymbol(namevals.front().getId());
    sym->Use(line);

    // Pull new size from param
    if (namevals.size() < 2)
        throw SyntaxError(N_("no size specified"));
    if (!namevals[1].isExpr())
        throw SyntaxError(N_("size must be an expression"));
    Expr size = namevals[1].getExpr(object, line);

    ElfSymbol& elfsym = BuildSymbol(*sym);
    elfsym.setSize(size, line);
}

void
ElfObject::DirWeak(Object& object,
                   NameValues& namevals,
                   NameValues& objext_namevals,
                   unsigned long line)
{
    assert(&m_object == &object);

    SymbolRef sym = object.getSymbol(namevals.front().getId());
    sym->Declare(Symbol::GLOBAL, line);

    ElfSymbol& elfsym = BuildSymbol(*sym);
    elfsym.setBinding(STB_WEAK);
}

void
ElfObject::DirIdent(Object& object,
                    NameValues& namevals,
                    NameValues& objext_namevals,
                    unsigned long line)
{
    assert(&m_object == &object);
    DirIdentCommon(*this, ".comment", object, namevals, objext_namevals,
                   line);
}

std::vector<const char*>
ElfObject::getDebugFormatKeywords()
{
    static const char* keywords[] =
    {
        "null",
        "stabs",
        "dwarf2"
    };
    return std::vector<const char*>(keywords, keywords+NELEMS(keywords));
}

void
ElfObject::AddDirectives(Directives& dirs, const char* parser)
{
    static const Directives::Init<ElfObject> nasm_dirs[] =
    {
        {"section", &ElfObject::DirSection, Directives::ARG_REQUIRED},
        {"segment", &ElfObject::DirSection, Directives::ARG_REQUIRED},
        {"type", &ElfObject::DirType, Directives::ID_REQUIRED},
        {"size", &ElfObject::DirSize, Directives::ID_REQUIRED},
        {"weak", &ElfObject::DirWeak, Directives::ID_REQUIRED},
        {"ident", &ElfObject::DirIdent, Directives::ANY},
    };
    static const Directives::Init<ElfObject> gas_dirs[] =
    {
        {".section", &ElfObject::DirGasSection, Directives::ARG_REQUIRED},
        {".type", &ElfObject::DirType, Directives::ID_REQUIRED},
        {".size", &ElfObject::DirSize, Directives::ID_REQUIRED},
        {".weak", &ElfObject::DirWeak, Directives::ID_REQUIRED},
        {".ident", &ElfObject::DirIdent, Directives::ANY},
    };

    if (String::NocaseEqual(parser, "nasm"))
        dirs.AddArray(this, nasm_dirs, NELEMS(nasm_dirs));
    else if (String::NocaseEqual(parser, "gas"))
        dirs.AddArray(this, gas_dirs, NELEMS(gas_dirs));
}
#if 0
static const char *elf_nasm_stdmac[] = {
    "%imacro type 1+.nolist",
    "[type %1]",
    "%endmacro",
    "%imacro size 1+.nolist",
    "[size %1]",
    "%endmacro",
    "%imacro weak 1+.nolist",
    "[weak %1]",
    "%endmacro",
    NULL
};

static const yasm_stdmac elf_objfmt_stdmacs[] = {
    { "nasm", "nasm", elf_nasm_stdmac },
    { NULL, NULL, NULL }
};
#endif
void
DoRegister()
{
    RegisterModule<ObjectFormatModule,
                   ObjectFormatModuleImpl<ElfObject> >("elf");
    RegisterModule<ObjectFormatModule,
                   ObjectFormatModuleImpl<Elf32Object> >("elf32");
    RegisterModule<ObjectFormatModule,
                   ObjectFormatModuleImpl<Elf64Object> >("elf64");
}

}}} // namespace yasm::objfmt::elf
