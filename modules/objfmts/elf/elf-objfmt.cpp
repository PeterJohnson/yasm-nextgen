//
// ELF object format
//
//  Copyright (C) 2003-2007  Michael Urman
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND OTHER CONTRIBUTORS ``AS IS''
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR OTHER CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Notes
//
// elf-objfmt uses the "linking" view of an ELF file:
// ELF header, an optional program header table, several sections,
// and a section header table
//
// The ELF header tells us some overall program information,
//   where to find the PHT (if it exists) with phnum and phentsize, 
//   and where to find the SHT with shnum and shentsize
//
// The PHT doesn't seem to be generated by NASM for elftest.asm
//
// The SHT
//
// Each Section is spatially disjoint, and has exactly one SHT entry.
//
#include <util.h>

#include <libyasmx/arch.h>
#include <libyasmx/bc_container_util.h>
#include <libyasmx/bc_output.h>
#include <libyasmx/bitcount.h>
#include <libyasmx/bytecode.h>
#include <libyasmx/compose.h>
#include <libyasmx/directive.h>
#include <libyasmx/errwarn.h>
#include <libyasmx/errwarns.h>
#include <libyasmx/location_util.h>
#include <libyasmx/object.h>
#include <libyasmx/object_format.h>
#include <libyasmx/name_value.h>
#include <libyasmx/nocase.h>
#include <libyasmx/registry.h>
#include <libyasmx/scoped_array.h>
#include <libyasmx/section.h>
#include <libyasmx/symbol_util.h>

#include "elf.h"
#include "elf-machine.h"


namespace yasm
{
namespace objfmt
{
namespace elf
{

inline bool
is_local(const Symbol& sym)
{
    int vis = sym.get_visibility();
    return (vis == Symbol::LOCAL || (vis & Symbol::DLOCAL) != 0);
}

class ElfObject : public ObjectFormat
{
public:
    ElfObject(unsigned int bits=0);
    ~ElfObject() {}

    std::string get_name() const;
    std::string get_keyword() const;
    void add_directives(Directives& dirs, const std::string& parser);

    std::string get_extension() const { return ".o"; }
    unsigned int get_default_x86_mode_bits() const;

    std::vector<std::string> get_dbgfmt_keywords() const;
    std::string get_default_dbgfmt_keyword() const { return "null"; }

    void init_symbols(const std::string& parser);

    bool taste(std::istream& is,
               /*@out@*/ std::string* arch_keyword,
               /*@out@*/ std::string* machine);
    void read(std::istream& is);
    void output(std::ostream& os, bool all_syms, Errwarns& errwarns);

    Section* add_default_section();
    Section* append_section(const std::string& name, unsigned long line);

    bool ok_object(Object* object) const;
    void initialize();

    ElfSymbol& build_symbol(Symbol& sym);
    void build_extern(Symbol& sym);
    void build_global(Symbol& sym);
    void build_common(Symbol& sym);
    void sym_set_sectval(Symbol& sym, ElfSymbol& elfsym);
    void finalize_symbol(Symbol& sym, ElfStrtab& strtab, bool local_names);

    void dir_section(Object& object,
                     NameValues& namevals,
                     NameValues& objext_namevals,
                     unsigned long line);
    void dir_type(Object& object,
                  NameValues& namevals,
                  NameValues& objext_namevals,
                  unsigned long line);
    void dir_size(Object& object,
                  NameValues& namevals,
                  NameValues& objext_namevals,
                  unsigned long line);
    void dir_weak(Object& object,
                  NameValues& namevals,
                  NameValues& objext_namevals,
                  unsigned long line);
    void dir_ident(Object& object,
                   NameValues& namevals,
                   NameValues& objext_namevals,
                   unsigned long line);

    ElfConfig m_config;                     // ELF configuration
    util::scoped_ptr<ElfMachine> m_machine; // ELF machine interface

    ElfSymbol* m_file_elfsym;               // .file symbol
    SymbolRef m_dotdotsym;                  // ..sym symbol
};

class Elf32Object : public ElfObject
{
public:
    Elf32Object() : ElfObject(32) {}
};

class Elf64Object : public ElfObject
{
public:
    Elf64Object() : ElfObject(64) {}
};

ElfObject::ElfObject(unsigned int bits)
    : m_machine(0)
    , m_file_elfsym(0)
    , m_dotdotsym(0)
{
    if (bits == 32)
        m_config.cls = ELFCLASS32;
    else if (bits == 64)
        m_config.cls = ELFCLASS64;
    else if (bits != 0)
        throw ValueError(String::compose(N_("unknown ELF bits setting %1"),
                                         bits));
}

std::string
ElfObject::get_name() const
{
    if (m_config.cls == ELFCLASS32)
        return "ELF (32-bit)";
    else if (m_config.cls == ELFCLASS64)
        return "ELF (64-bit)";
    else
        return "ELF";
}

std::string
ElfObject::get_keyword() const
{
    if (m_config.cls == ELFCLASS32)
        return "elf32";
    else if (m_config.cls == ELFCLASS64)
        return "elf64";
    else
        return "elf";
}

unsigned int
ElfObject::get_default_x86_mode_bits() const
{
    if (m_config.cls == ELFCLASS32)
        return 32;
    else if (m_config.cls == ELFCLASS64)
        return 64;
    else
        return 0;
}

bool
ElfObject::ok_object(Object* object) const
{
    return ok_elf_machine(*object->get_arch(), m_config.cls);
}

bool
ElfObject::taste(std::istream& is,
                 /*@out@*/ std::string* arch_keyword,
                 /*@out@*/ std::string* machine)
{
    // Read header
    if (!m_config.proghead_read(is))
        return false;

    // for now, just handle this here
    switch (m_config.machine_type)
    {
        case EM_386:
            arch_keyword->assign("x86");
            machine->assign("x86");
            break;
        case EM_X86_64:
            arch_keyword->assign("x86");
            machine->assign("amd64");
            break;
        default:
            return false;
    }
    return true;
}

void
ElfObject::read(std::istream& is)
{
    // Read header
    if (!m_config.proghead_read(is))
        throw Error(N_("not an ELF file"));

    // Can't handle files without section table yet
    if (m_config.secthead_pos == 0)
        throw Error(N_("no section table"));

    // Read section string table (needed for section names)
    is.seekg(m_config.secthead_pos +
             m_config.shstrtab_index * m_config.secthead_size);
    if (!is)
        throw Error(N_("could not read .shstrtab section header"));

    std::auto_ptr<ElfSection>
        shstrtab_sect(new ElfSection(m_config, is, m_config.shstrtab_index));

    ElfStrtab shstrtab;
    is.seekg(shstrtab_sect->get_file_offset());
    shstrtab.read(is, shstrtab_sect->get_size().get_uint());
    if (!is)
        throw Error(N_("could not read .shstrtab string data"));

    // Read all section headers

    // owned storage for "misc" sections (e.g. relocation sections)
    stdx::ptr_vector<ElfSection> misc_sections;
    stdx::ptr_vector_owner<ElfSection> misc_sections_owner(misc_sections);
    misc_sections.reserve(m_config.secthead_count);

    // indexed array of all ElfSections by section index
    util::scoped_array<ElfSection*>
        elfsects(new ElfSection*[m_config.secthead_count]);
    // indexed array of all Sections by section index
    util::scoped_array<Section*>
        sections(new Section*[m_config.secthead_count]);

    // special sections
    ElfSection* strtab_sect = 0;
    ElfSection* symtab_sect = 0;

    // read section headers
    is.seekg(m_config.secthead_pos);
    for (unsigned int i=0; i<m_config.secthead_count; ++i)
    {
        // read section header and save by index
        std::auto_ptr<ElfSection> elfsect(new ElfSection(m_config, is, i));
        elfsects[i] = elfsect.get();

        std::string sectname = shstrtab.get_str(elfsect->get_name());
        if (sectname == ".strtab")
        {
            strtab_sect = elfsect.get();
        }
        else if (sectname == ".symtab")
        {
            symtab_sect = elfsect.get();
        }

        ElfSectionType secttype = elfsect->get_type();
        if (secttype == SHT_NULL ||
            secttype == SHT_SYMTAB ||
            secttype == SHT_STRTAB ||
            secttype == SHT_RELA ||
            secttype == SHT_REL)
        {
            misc_sections.push_back(elfsect.release());
            sections[i] = 0;

            // try to pick these up by section type if not set
            if (secttype == SHT_SYMTAB && symtab_sect == 0)
                symtab_sect = elfsect.get();
            else if (secttype == SHT_STRTAB && strtab_sect == 0)
                strtab_sect = elfsect.get();

            // if any section is RELA, set config to RELA
            if (secttype == SHT_RELA)
                m_config.rela = true;
        }
        else
        {
            std::auto_ptr<Section> section = elfsect->create_section(shstrtab);
            elfsect->load_section_data(*section, is);
            sections[i] = section.get();

            // Associate section data with section
            section->add_assoc_data(ElfSection::key,
                std::auto_ptr<AssocData>(elfsect.release()));

            // Add section to object
            m_object->append_section(section);
        }
    }

    // Symbol table by index (needed for relocation lookups by index)
    std::vector<SymbolRef> symtab;

    // read symtab string table and symbol table (if present)
    if (symtab_sect != 0)
    {
        // get string table section index from symtab link field if reasonable
        ElfSectionIndex link = symtab_sect->get_link();
        if (link < m_config.secthead_count &&
            elfsects[link]->get_type() == SHT_STRTAB)
            strtab_sect = elfsects[link];

        if (strtab_sect == 0)
            throw Error(N_("could not find symbol string table"));

        // load symbol string table
        ElfStrtab strtab;
        is.seekg(strtab_sect->get_file_offset());
        strtab.read(is, strtab_sect->get_size().get_uint());
        if (!is)
            throw Error(N_("could not read symbol string data"));

        // load symbol table
        unsigned long symtab_size = symtab_sect->get_size().get_uint();
        ElfSize symsize = symtab_sect->get_entsize();
        if (symsize == 0)
            throw Error(N_("symbol table entity size is zero"));
        is.seekg(symtab_sect->get_file_offset());
        if (!m_config.symtab_read(is, symtab, *m_object, symtab_size, symsize,
                                  strtab, &sections[0]))
            throw Error(N_("could not read symbol table"));
    }

    // go through misc sections to load relocations
    for (unsigned int i=0; i<m_config.secthead_count; ++i)
    {
        ElfSection* reloc_sect = elfsects[i];
        ElfSectionType secttype = reloc_sect->get_type();
        if (secttype != SHT_REL && secttype != SHT_RELA)
            continue;

        // get symbol table section index from link field (if valid)
        ElfSection* rel_symtab_sect = symtab_sect;
        ElfSectionIndex link = reloc_sect->get_link();
        if (link < m_config.secthead_count &&
            elfsects[link]->get_type() == SHT_SYMTAB)
        {
            if (rel_symtab_sect != elfsects[link])
            {
                throw Error(N_("only one symbol table supported"));
            }
        }

        // section relocs apply to is indicated by info field
        ElfSectionIndex info = reloc_sect->get_info();
        if (link >= m_config.secthead_count || sections[info] == 0)
            continue;

        // load relocations
        is.seekg(reloc_sect->get_file_offset());
        unsigned long relocs_size = reloc_sect->get_size().get_uint();
        if (!elfsects[info]->read_relocs(is, *sections[info], relocs_size,
                                         *m_machine, symtab,
                                         secttype == SHT_RELA))
            throw Error(String::compose(
                N_("could not read section `%1' relocations"),
                sections[info]->get_name()));
    }
}

void
ElfObject::initialize()
{
    m_machine.reset(create_elf_machine(*m_object->get_arch(),
                                       m_config.cls).release());
    m_machine->configure(&m_config);
}

void
ElfObject::init_symbols(const std::string& parser)
{
    // Add .file symbol
    SymbolRef filesym = m_object->append_symbol(std::auto_ptr<Symbol>(
        new Symbol(".file")));
    filesym->define_special(Symbol::LOCAL);

    std::auto_ptr<ElfSymbol> elfsym(new ElfSymbol());
    elfsym->set_index(SHN_ABS);
    elfsym->set_binding(STB_LOCAL);
    elfsym->set_type(STT_FILE);
    m_file_elfsym = elfsym.get();

    filesym->add_assoc_data(ElfSymbol::key,
                            std::auto_ptr<AssocData>(elfsym.release()));

    // Create ..sym special symbol (NASM only)
    if (String::nocase_equal(parser, "nasm"))
    {
        std::auto_ptr<Symbol> sym(new Symbol("sym"));
        sym->define_special(Symbol::EXTERN);
        m_dotdotsym = m_object->add_special_sym(sym);
    }

    // Create machine-specific special symbols
    m_machine->add_special_syms(*m_object, parser);
}

ElfSymbol&
ElfObject::build_symbol(Symbol& sym)
{
    ElfSymbol* elfsym = get_elf(sym);

    if (!elfsym)
    {
        elfsym = new ElfSymbol;
        sym.add_assoc_data(ElfSymbol::key, std::auto_ptr<AssocData>(elfsym));
    }

    return *elfsym;
}

void
ElfObject::build_extern(Symbol& sym)
{
    const NameValues* objext_nvs = get_objext_namevals(sym);

    if (objext_nvs)
    {
        for (NameValues::const_iterator nv=objext_nvs->begin(),
             end=objext_nvs->end(); nv != end; ++nv)
        {
            if (nv->is_string())
            {
                throw TypeError(String::compose(
                    N_("unrecognized symbol type `%1'"), nv->get_string()));
            }
        }
    }

    ElfSymbol& elfsym = build_symbol(sym);
    elfsym.set_binding(STB_GLOBAL);
}

static bool
global_nameval_fallback(NameValue& nv, Object* object, unsigned long line,
                        Expr::Ptr* size)

{
    if (!nv.is_expr() && nv.is_id())
    {
        throw TypeError(String::compose(N_("unrecognized symbol type `%s'"),
                                        nv.get_id()));
    }
    else if (nv.is_expr() && size->get() == 0)
    {
        *size = nv.release_expr(*object, line);
        return true;
    }
    else
        return dir_nameval_warn(nv);
}

inline static void
global_set_vis(NameValue& nv, ElfSymbolVis* vis_out, unsigned int* vis_count,
               ElfSymbolVis vis)
{
    *vis_out = vis;
    *vis_count = *vis_count + 1;
}


void
ElfObject::build_global(Symbol& sym)
{
    Expr::Ptr size(0);
    unsigned long type = STT_NOTYPE;    // ElfSymbolType
    ElfSymbolVis vis = STV_DEFAULT;
    unsigned int nvis = 0;

    DirHelpers helpers;

    helpers.add("function", false,
                BIND::bind(&dir_flag_reset, _1, &type, STT_FUNC));
    helpers.add("data", false,
                BIND::bind(&dir_flag_reset, _1, &type, STT_OBJECT));
    helpers.add("object", false,
                BIND::bind(&dir_flag_reset, _1, &type, STT_OBJECT));
    helpers.add("object", false,
                BIND::bind(&dir_flag_reset, _1, &type, STT_OBJECT));
    helpers.add("internal", false,
                BIND::bind(&global_set_vis, _1, &vis, &nvis, STV_INTERNAL));
    helpers.add("hidden", false,
                BIND::bind(&global_set_vis, _1, &vis, &nvis, STV_HIDDEN));
    helpers.add("protected", false,
                BIND::bind(&global_set_vis, _1, &vis, &nvis, STV_PROTECTED));

    NameValues* objext_nvs = get_objext_namevals(sym);
    if (objext_nvs)
    {
        helpers(objext_nvs->begin(), objext_nvs->end(),
                BIND::bind(&global_nameval_fallback, _1, m_object,
                           sym.get_decl_line(), &size));
    }

    if (nvis > 1)
    {
        warn_set(WARN_GENERAL,
            N_("More than one symbol visibility provided; using last"));
    }

    ElfSymbol& elfsym = build_symbol(sym);
    elfsym.set_binding(STB_GLOBAL);
    elfsym.set_type(static_cast<ElfSymbolType>(type));
    elfsym.set_visibility(vis);
    if (size.get() != 0)
        elfsym.set_size(size);
}

void
ElfObject::build_common(Symbol& sym)
{
    NameValues* objext_nvs = get_objext_namevals(sym);
    unsigned long addralign = 0;

    if (objext_nvs)
    {
        for (NameValues::iterator nv=objext_nvs->begin(),
             end=objext_nvs->end(); nv != end; ++nv)
        {
            if (!nv->get_name().empty())
            {
                warn_set(WARN_GENERAL, String::compose(
                    N_("Unrecognized qualifier `%1'"), nv->get_name()));
                continue;
            }

            if (!nv->is_expr())
                throw ValueError(N_("alignment constraint is not an integer"));

            std::auto_ptr<Expr> align_expr =
                nv->release_expr(*m_object, sym.get_decl_line());
            const IntNum* align_intn = align_expr->get_intnum();
            if (!align_intn)
                throw ValueError(N_("alignment constraint is not an integer"));
            addralign = align_intn->get_uint();

            // Alignments must be a power of two.
            if (!is_exp2(addralign))
            {
                throw ValueError(
                    N_("alignment constraint is not a power of two"));
            }
        }
    }

    ElfSymbol& elfsym = build_symbol(sym);
    elfsym.set_index(SHN_COMMON);
    elfsym.set_binding(STB_GLOBAL);
    elfsym.set_size(Expr::Ptr(get_common_size(sym)->clone()));
    elfsym.set_value(addralign);
}

void
ElfObject::sym_set_sectval(Symbol& sym, ElfSymbol& elfsym)
{
    Location loc;
    if (!sym.get_label(&loc))
        return;

    if (loc.bc)
    {
        elfsym.set_section(loc.bc->get_container()->as_section());
        elfsym.set_value(loc.get_offset());
    }
}

void
ElfObject::finalize_symbol(Symbol& sym, ElfStrtab& strtab, bool local_names)
{
    int vis = sym.get_visibility();
    int status = sym.get_status();
    ElfSymbol* elfsym = get_elf(sym);

    if (vis & Symbol::EXTERN)
    {
        build_extern(sym);
        elfsym = get_elf(sym);
        elfsym->set_name(strtab.get_index(sym.get_name()));
        return;
    }

    if (vis & Symbol::COMMON)
    {
        build_common(sym);
        elfsym = get_elf(sym);
        elfsym->set_name(strtab.get_index(sym.get_name()));
        // fall through (check below catches undefined case)
    }

    // Ignore any undefined at this point.
    if (!(status & Symbol::DEFINED))
        return;

    if (elfsym)
        ;
    else if (vis & Symbol::GLOBAL)
    {
        build_global(sym);
        elfsym = get_elf(sym);
        elfsym->set_name(strtab.get_index(sym.get_name()));
    }
    else
    {
        Location loc = {0, 0};
        if (!sym.get_label(&loc))
        {
            if (!sym.get_equ() && !sym.is_abs())
                return;
        }

        Section* sect = 0;
        if (loc.bc)
            sect = loc.bc->get_container()->as_section();

        // Locals (except when debugging) do not need to be
        // in the symbol table, unless they're a section.
        bool is_sect = false;
        if (sect)
        {
            ElfSection* elfsect = get_elf(*sect);
            if (elfsect && elfsect->get_sym() == &sym)
                is_sect = true;
        }

        if (!local_names && !is_sect)
            return;

        if (sym.get_equ() && !sym.is_abs())
            return;

        elfsym = &build_symbol(sym);
        if (local_names || is_sect)
            elfsym->set_name(strtab.get_index(sym.get_name()));
        if (is_sect)
            elfsym->set_type(STT_SECTION);
    }

    sym_set_sectval(sym, *elfsym);
}

class Output : public BytecodeStreamOutput
{
public:
    Output(std::ostream& os, ElfObject& objfmt, Object& object);
    ~Output();

    void output_section(Section& sect,
                        unsigned int* sindex,
                        ElfStrtab& shstrtab,
                        Errwarns& errwarns);

    // OutputBytecode overrides
    using BytecodeStreamOutput::output;
    void output(Value& value, Bytes& bytes, Location loc, int warn);
    void output(SymbolRef sym,
                Bytes& bytes,
                Location loc,
                unsigned int valsize,
                int warn);

private:
    ElfObject& m_objfmt;
    Object& m_object;
    BytecodeNoOutput m_no_output;
};

Output::Output(std::ostream& os, ElfObject& objfmt, Object& object)
    : BytecodeStreamOutput(os)
    , m_objfmt(objfmt)
    , m_object(object)
{
}

Output::~Output()
{
}

void
Output::output(SymbolRef sym,
               Bytes& bytes,
               Location loc,
               unsigned int valsize,
               int warn)
{
    std::auto_ptr<ElfReloc> reloc =
        m_objfmt.m_machine->make_reloc(sym, SymbolRef(0), loc.get_offset(),
                                       false, valsize);

    // allocate .rel[a] sections on a need-basis
    Section* sect = loc.bc->get_container()->as_section();
    sect->add_reloc(std::auto_ptr<Reloc>(reloc.release()));

    m_object.get_arch()->tobytes(0, bytes, valsize, 0, warn);
    m_os << bytes;
}

void
Output::output(Value& value, Bytes& bytes, Location loc, int warn)
{
    if (Expr* e = value.get_abs())
        e->simplify(&xform_calc_dist);

    // Try to output constant and PC-relative section-local first.
    // Note this does NOT output any value with a SEG, WRT, external,
    // cross-section, or non-PC-relative reference (those are handled below).
    if (value.output_basic(bytes, loc, warn, *m_object.get_arch()))
    {
        m_os << bytes;
        return;
    }

    // Handle other expressions, with relocation if necessary
    if (value.m_seg_of || value.m_section_rel || value.m_rshift > 0)
        throw TooComplexError(N_("elf: relocation too complex"));

    IntNum intn(0);
    ElfReloc* reloc = 0;
    if (value.is_relative())
    {
        SymbolRef sym = value.m_rel;
        SymbolRef wrt = value.m_wrt;

        if (wrt == m_objfmt.m_dotdotsym)
            wrt = SymbolRef(0);
        else if (wrt && is_wrt_sym_relative(*wrt))
            ;
        else if (wrt && is_wrt_pos_adjusted(*wrt))
            intn = loc.get_offset();
        else if (is_local(*sym))
        {
            // Local symbols need relocation to their section's start, and
            // add in the offset of the bytecode (within the target section)
            // into the abs portion.
            //
            // This is only done if the symbol is relocated against the
            // section instead of the symbol itself.
            Location symloc;
            if (sym->get_label(&symloc))
            {
                // Relocate to section start
                Section* sym_sect = symloc.bc->get_container()->as_section();
                ElfSection* elfsect = get_elf(*sym_sect);
                assert(elfsect != 0);
                sym = elfsect->get_sym();

                intn = symloc.get_offset();
            }
        }

        // allocate .rel[a] sections on a need-basis
        Section* sect = loc.bc->get_container()->as_section();
        std::auto_ptr<ElfReloc> reloc_auto =
            m_objfmt.m_machine->make_reloc(sym, wrt, loc.get_offset(),
                                           value.m_curpos_rel, value.m_size);
        reloc = reloc_auto.get();
        sect->add_reloc(std::auto_ptr<Reloc>(reloc_auto.release()));
    }

    if (Expr* abs = value.get_abs())
    {
        IntNum* intn2 = abs->get_intnum();
        if (!intn2)
            throw TooComplexError(N_("elf: relocation too complex"));
        intn += *intn2;
    }

    if (reloc)
        reloc->handle_addend(&intn, m_objfmt.m_config);
    m_object.get_arch()->tobytes(intn, bytes, value.m_size, 0, warn);
    m_os << bytes;
}
#if 0
static int
elf_objfmt_create_dbg_secthead(yasm_section *sect, /*@null@*/ void *d)
{
    /*@null@*/ elf_objfmt_output_info *info = (elf_objfmt_output_info *)d;
    elf_secthead *shead;
    elf_section_type type=SHT_PROGBITS;
    elf_size entsize=0;
    const char *sectname;
    /*@dependent@*/ yasm_symrec *sym;
    elf_strtab_entry *name;

    shead = yasm_section_get_data(sect, &elf_section_data);
    if (shead)
        return 0;   /* only create new secthead if missing */

    sectname = yasm_section_get_name(sect);
    name = elf_strtab_append_str(info->objfmt_elf->shstrtab, sectname);

    if (yasm__strcasecmp(sectname, ".stab")==0) {
        entsize = 12;
    } else if (yasm__strcasecmp(sectname, ".stabstr")==0) {
        type = SHT_STRTAB;
    } else if (yasm__strncasecmp(sectname, ".debug_", 7)==0) {
        ;
    } else
        yasm_internal_error(N_("Unrecognized section without data"));

    shead = elf_secthead_create(name, type, 0, 0, 0);
    elf_secthead_set_entsize(shead, entsize);

    sym = yasm_symtab_define_label(info->object->symtab, sectname,
                                   yasm_section_bcs_first(sect), 1, 0);
    elf_secthead_set_sym(shead, sym);

    yasm_section_add_data(sect, &elf_section_data, shead);

    return 0;
}
#endif
void
Output::output_section(Section& sect,
                       unsigned int* sindex,
                       ElfStrtab& shstrtab,
                       Errwarns& errwarns)
{
    BytecodeOutput* outputter = this;

    ElfSection* elfsect = get_elf(sect);
    assert(elfsect != 0);

    if (elfsect->get_align() == 0)
        elfsect->set_align(sect.get_align());

    elfsect->set_name(shstrtab.get_index(sect.get_name()));
    elfsect->set_index(*sindex);
    *sindex = *sindex + 1;

    std::streampos pos;
    if (sect.is_bss())
    {
        // Don't output BSS sections.
        outputter = &m_no_output;
        pos = 0;    // position = 0 because it's not in the file
    }
    else
    {
        pos = m_os.tellp();
        if (pos < 0)
            throw IOError(N_("couldn't read position on output stream"));

        if (sect.bcs_last().next_offset() == 0)
            return;

        m_os.seekp(elfsect->set_file_offset(pos));
        if (!m_os)
            throw IOError(N_("couldn't seek on output stream"));
    }

    // Output bytecodes
    for (Section::bc_iterator i=sect.bcs_begin(), end=sect.bcs_end();
         i != end; ++i)
    {
        try
        {
            i->output(*outputter);
            elfsect->add_size(i->get_total_len());
        }
        catch (Error& err)
        {
            errwarns.propagate(i->get_line(), err);
        }
        errwarns.propagate(i->get_line());  // propagate warnings
    }

    // Sanity check final section size
    assert(elfsect->get_size() == sect.bcs_last().next_offset());

    // Empty?  Go on to next section
    if (elfsect->is_empty())
        return;

    // No relocations?  Go on to next section
    if (sect.get_relocs().size() == 0)
        return;

    // need relocation section; set it up
    elfsect->set_rel_index(*sindex);
    *sindex = *sindex + 1;

    // name the relocation section .rel[a].foo
    std::string relname = m_objfmt.m_config.name_reloc_section(sect.get_name());
    elfsect->set_rel_name(shstrtab.get_index(relname));
}

unsigned long
output_align(std::ostream& os, unsigned int align)
{
    if (!is_exp2(align))
        throw InternalError("requested alignment not a power of two");

    std::streampos pos = os.tellp();
    if (pos < 0)
        throw IOError(N_("could not get file position on output file"));

    unsigned long delta = align - (pos & (align-1)); 
    if (delta != align)
    {
        pos += delta;
        os.seekp(pos);
        if (!os)
            throw IOError(N_("could not set file position on output file"));
    }
    return static_cast<unsigned long>(pos);
}

void
ElfObject::output(std::ostream& os, bool all_syms, Errwarns& errwarns)
{
    ElfStrtab shstrtab, strtab;

    // Add filename to strtab and set as .file symbol name
    if (m_file_elfsym)
    {
        m_file_elfsym->set_name(strtab.get_index(m_object->get_source_fn()));
    }

    // Allocate space for Ehdr by seeking forward
    os.seekp(m_config.proghead_get_size());
    if (!os)
        throw IOError(N_("could not seek on output file"));

    // Create missing section headers
#if 0
    if (yasm_object_sections_traverse(object, &info,
                                      elf_objfmt_create_dbg_secthead))
        return;
#endif
    // Finalize symbol table, handling any objfmt-specific extensions given
    // during parse phase.  If all_syms is true, add all local symbols and
    // include name information.
    for (Object::symbol_iterator i=m_object->symbols_begin(),
         end=m_object->symbols_end(); i != end; ++i)
    {
        try
        {
            finalize_symbol(*i, strtab, all_syms);
        }
        catch (Error& err)
        {
            errwarns.propagate(i->get_decl_line(), err);
        }
        errwarns.propagate(i->get_decl_line());
    }

    m_config.secthead_count = 0;

    // dummy section header
    ElfSection null_sect(m_config, SHT_NULL, 0);
    null_sect.set_index(m_config.secthead_count++);

    Output out(os, *this, *m_object);

    // Output user sections.
    // Assign indices and names as we go (including for relocation sections).
    for (Object::section_iterator i=m_object->sections_begin(),
         end=m_object->sections_end(); i != end; ++i)
    {
        out.output_section(*i, &m_config.secthead_count, shstrtab, errwarns);
    }

    // If we're not forcing all symbols to be in the table, go through
    // relocations and force referenced symbols into symbol table, because
    // relocation needs a symtab index.
    if (!all_syms)
    {
        for (Object::section_iterator sect=m_object->sections_begin(),
             endsect=m_object->sections_end(); sect != endsect; ++sect)
        {
            for (Section::reloc_iterator reloc=sect->relocs_begin(),
                 endreloc=sect->relocs_end(); reloc != endreloc; ++reloc)
            {
                SymbolRef sym = reloc->get_sym();
                ElfSymbol& elfsym = build_symbol(*sym); // XXX
                elfsym.set_name(strtab.get_index(sym->get_name()));
                sym_set_sectval(*sym, elfsym);
            }
        }
    }

    // Partition symbol table to put local symbols first
    stdx::stable_partition(m_object->symbols_begin(), m_object->symbols_end(),
                           is_local);

    // Number symbols.
    ElfSymbolIndex symtab_nlocal;
    m_config.symtab_setindexes(*m_object, &symtab_nlocal);

    unsigned long offset, size;
    ElfStringIndex shstrtab_name = shstrtab.get_index(".shstrtab");
    ElfStringIndex strtab_name = shstrtab.get_index(".strtab");
    ElfStringIndex symtab_name = shstrtab.get_index(".symtab");

    // section header string table (.shstrtab)
    offset = output_align(os, 4);
    size = shstrtab.write(os);

    ElfSection shstrtab_sect(m_config, SHT_STRTAB, 0);
    m_config.shstrtab_index = m_config.secthead_count;
    shstrtab_sect.set_name(shstrtab_name);
    shstrtab_sect.set_index(m_config.secthead_count++);
    shstrtab_sect.set_file_offset(offset);
    shstrtab_sect.set_size(size);

    // string table (.strtab)
    offset = output_align(os, 4);
    size = strtab.write(os);

    ElfSection strtab_sect(m_config, SHT_STRTAB, 0);
    strtab_sect.set_name(strtab_name);
    strtab_sect.set_index(m_config.secthead_count++);
    strtab_sect.set_file_offset(offset);
    strtab_sect.set_size(size);

    // symbol table (.symtab)
    offset = output_align(os, 4);
    size = m_config.symtab_write(os, *m_object, errwarns, out.get_scratch());

    ElfSection symtab_sect(m_config, SHT_SYMTAB, 0, true);
    symtab_sect.set_name(symtab_name);
    symtab_sect.set_index(m_config.secthead_count++);
    symtab_sect.set_file_offset(offset);
    symtab_sect.set_size(size);
    symtab_sect.set_info(symtab_nlocal);
    symtab_sect.set_link(strtab_sect.get_index());  // link to .strtab

    // output relocations
    for (Object::section_iterator i=m_object->sections_begin(),
         end=m_object->sections_end(); i != end; ++i)
    {
        // No relocations to output?  Go on to next section
        if (i->get_relocs().size() == 0)
            continue;

        ElfSection* elfsect = get_elf(*i);
        assert(elfsect != 0);
        elfsect->write_relocs(os, *i, errwarns, out.get_scratch(),
                              *m_machine);
    }

    // output section header table
    m_config.secthead_pos = output_align(os, 16);

#if 0
    // stabs debugging support
    if (strcmp(yasm_dbgfmt_keyword(object->dbgfmt), "stabs")==0)
    {
        Section* stabsect = m_object->find_section(".stab");
        Section* stabstrsect = m_object->find_section(".stabstr");
        if (stabsect && stabstrsect)
        {
            ElfSection* stab = get_elf(*stabsect);
            ElfSection* stabstr = get_elf(*stabstrsect);
            if (stab && stabstr)
                stab->set_link(stabstr->get_index());
            else
                throw InternalError(N_("missing .stab or .stabstr section/data"));
        }
    }
#endif

    // null section header
    null_sect.write(os, out.get_scratch());

    // user section headers (and relocation section headers)
    for (Object::section_iterator i=m_object->sections_begin(),
         end=m_object->sections_end(); i != end; ++i)
    {
        ElfSection* elfsect = get_elf(*i);
        assert(elfsect != 0);

        if (elfsect->write(os, out.get_scratch()) == 0)
            continue;

        // relocation entries for .foo are stored in section .rel[a].foo
        elfsect->write_rel(os, symtab_sect.get_index(), *i, out.get_scratch());
    }

    // standard section headers
    shstrtab_sect.write(os, out.get_scratch());
    strtab_sect.write(os, out.get_scratch());
    symtab_sect.write(os, out.get_scratch());

    // output Ehdr
    os.seekp(0);
    if (!os)
        throw IOError(N_("could not seek on output file"));

    m_config.proghead_write(os, out.get_scratch());
}

Section*
ElfObject::add_default_section()
{
    Section* section = append_section(".text", 0);
    section->set_default(true);
    return section;
}

Section*
ElfObject::append_section(const std::string& name, unsigned long line)
{
    ElfSectionType type = SHT_PROGBITS;
    ElfSectionFlags flags = SHF_ALLOC;
    unsigned long align = 4;

    if (name == ".bss")
    {
        type = SHT_NOBITS;
        flags = SHF_ALLOC + SHF_WRITE;
    }
    else if (name == ".data")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_WRITE;
    }
    else if (name == ".tdata")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_WRITE + SHF_TLS;
    }
    else if (name == ".rodata")
    {
        type = SHT_PROGBITS;
        flags = SHF_ALLOC;
    }
    else if (name == ".text")
    {
        align = 16;
        type = SHT_PROGBITS;
        flags = SHF_ALLOC + SHF_EXECINSTR;
    }
    else if (name == ".comment")
    {
        align = 0;
        type = SHT_PROGBITS;
        flags = 0;
    }
    else
    {
        // Default to code, but align=1
        align = 1;
    }

    bool code = (flags & SHF_EXECINSTR) != 0;
    bool bss = (type == SHT_NOBITS);

    Section* section = new Section(name, code, bss, line);
    m_object->append_section(std::auto_ptr<Section>(section));
    section->set_align(align);

    // Define a label for the start of the section
    Location start = {&section->bcs_first(), 0};
    SymbolRef sym = m_object->get_sym(name);
    sym->define_label(start, line);

    // Add ELF data to the section
    ElfSection* elfsect = new ElfSection(m_config, type, flags);
    section->add_assoc_data(ElfSection::key, std::auto_ptr<AssocData>(elfsect));
    elfsect->set_sym(sym);

    return section;
}
#if 0
/* GAS-style flags */
static int
elf_helper_gasflags(void *obj, yasm_valparam *vp, unsigned long line, void *d,
                    /*@unused@*/ uintptr_t arg)
{
    struct elf_section_switch_data *data = (struct elf_section_switch_data *)d;
    const char *s = yasm_vp_string(vp);
    size_t i;

    if (!s) {
        yasm_error_set(YASM_ERROR_VALUE,
                       N_("non-string section attribute"));
        return -1;
    }

    data->flags = 0;
    for (i=0; i<strlen(s); i++) {
        switch (s[i]) {
            case 'a':
                data->flags |= SHF_ALLOC;
                break;
            case 'w':
                data->flags |= SHF_WRITE;
                break;
            case 'x':
                data->flags |= SHF_EXECINSTR;
                break;
            case 'M':
                data->flags |= SHF_MERGE;
                break;
            case 'S':
                data->flags |= SHF_STRINGS;
                break;
            case 'G':
                data->flags |= SHF_GROUP;
                break;
            case 'T':
                data->flags |= SHF_TLS;
                break;
            default:
                yasm_warn_set(YASM_WARN_GENERAL,
                              N_("unrecognized section attribute: `%c'"),
                              s[i]);
        }
    }

    data->gasflags = 1;
    return 0;
}
#endif
void
ElfObject::dir_section(Object& object,
                       NameValues& nvs,
                       NameValues& objext_nvs,
                       unsigned long line)
{
    assert(&object == m_object);

    if (!nvs.front().is_string())
        throw Error(N_("section name must be a string"));
    std::string sectname = nvs.front().get_string();

    Section* sect = m_object->find_section(sectname);
    bool first = true;
    if (sect)
        first = sect->is_default();
    else
        sect = append_section(sectname, line);

    m_object->set_cur_section(sect);
    sect->set_default(false);

    // No name/values, so nothing more to do
    if (nvs.size() <= 1)
        return;

    // Ignore flags if we've seen this section before
    if (!first)
    {
        warn_set(WARN_GENERAL,
                 N_("section flags ignored on section redeclaration"));
        return;
    }

    // Parse section flags
    ElfSection* elfsect = get_elf(*sect);
    assert(elfsect != 0);

    IntNum align;
    bool has_align = false;
    IntNum merge;
    bool has_merge = false;

    unsigned long type = elfsect->get_type();
    unsigned long flags = elfsect->get_flags();

    DirHelpers helpers;
    static const struct
    {
        const char* enable;
        const char* disable;
        unsigned int flag;
    }
    name_flags[] =
    {
        {"alloc",   "noalloc",  SHF_ALLOC},
        {"exec",    "noexec",   SHF_EXECINSTR},
        {"write",   "nowrite",  SHF_WRITE},
        {"tls",     "notls",    SHF_TLS},
    };
    for (unsigned int i=0; i<NELEMS(name_flags); ++i)
    {
        helpers.add(name_flags[i].enable, false,
                    BIND::bind(&dir_flag_set, _1, &flags, name_flags[i].flag));
        helpers.add(name_flags[i].disable, false,
                    BIND::bind(&dir_flag_clear, _1, &flags,
                               name_flags[i].flag));
    }

    helpers.add("noprogbits", false,
                BIND::bind(&dir_flag_reset, _1, &type, SHT_NOBITS));
    helpers.add("nobits", false,
                BIND::bind(&dir_flag_reset, _1, &type, SHT_NOBITS));
    helpers.add("progbits", false,
                BIND::bind(&dir_flag_reset, _1, &type, SHT_PROGBITS));

    helpers.add("align", true,
                BIND::bind(&dir_intn, _1, m_object, line, &align, &has_align));
    helpers.add("merge", true,
                BIND::bind(&dir_intn, _1, m_object, line, &merge, &has_merge));

    helpers(++nvs.begin(), nvs.end(), dir_nameval_warn);

    // handle align
    if (has_align)
    {
        unsigned long aligni = align.get_uint();

        // Alignments must be a power of two.
        if (!is_exp2(aligni))
        {
            throw ValueError(String::compose(
                N_("argument to `%1' is not a power of two"), "align"));
        }

        sect->set_align(aligni);
    }

    // Handle merge entity size
    if (has_merge)
    {
        flags |= SHF_MERGE;
        elfsect->set_entsize(merge.get_uint());
    }

    elfsect->set_typeflags(static_cast<ElfSectionType>(type),
                           static_cast<ElfSectionFlags>(flags));
    sect->set_bss(type == SHT_NOBITS);
    sect->set_code((flags & SHF_EXECINSTR) != 0);
}

void
ElfObject::dir_type(Object& object,
                    NameValues& namevals,
                    NameValues& objext_namevals,
                    unsigned long line)
{
    assert(m_object == &object);

    SymbolRef sym = object.get_sym(namevals.front().get_id());
    sym->use(line);

    ElfSymbol& elfsym = build_symbol(*sym);

    // Pull new type from param
    if (namevals.size() < 2)
        throw SyntaxError(N_("no type specified"));
    if (!namevals[1].is_id())
        throw SyntaxError(N_("type must be an identifier"));

    std::string type = namevals[1].get_id();
    if (String::nocase_equal(type, "function"))
        elfsym.set_type(STT_FUNC);
    else if (String::nocase_equal(type, "object"))
        elfsym.set_type(STT_OBJECT);
    else if (String::nocase_equal(type, "tls_object"))
        elfsym.set_type(STT_TLS);
    else if (String::nocase_equal(type, "notype"))
        elfsym.set_type(STT_NOTYPE);
    else
        warn_set(WARN_GENERAL,
                 String::compose(N_("unrecognized symbol type `%s'"), type));
}

void
ElfObject::dir_size(Object& object,
                    NameValues& namevals,
                    NameValues& objext_namevals,
                    unsigned long line)
{
    assert(m_object == &object);

    SymbolRef sym = object.get_sym(namevals.front().get_id());
    sym->use(line);

    // Pull new size from param
    if (namevals.size() < 2)
        throw SyntaxError(N_("no size specified"));
    Expr::Ptr size = namevals[1].get_expr(object, line);
    if (size.get() == 0)
        throw SyntaxError(N_("size must be an expression"));

    ElfSymbol& elfsym = build_symbol(*sym);
    elfsym.set_size(size);
}

void
ElfObject::dir_weak(Object& object,
                    NameValues& namevals,
                    NameValues& objext_namevals,
                    unsigned long line)
{
    assert(m_object == &object);

    SymbolRef sym = object.get_sym(namevals.front().get_id());
    sym->declare(Symbol::GLOBAL, line);

    ElfSymbol& elfsym = build_symbol(*sym);
    elfsym.set_binding(STB_WEAK);
}

void
ElfObject::dir_ident(Object& object,
                     NameValues& namevals,
                     NameValues& objext_namevals,
                     unsigned long line)
{
    assert(m_object == &object);

    // Accept, but do nothing with empty ident
    if (namevals.empty())
        return;

    // Put ident data into .comment section
    Section* comment = object.find_section(".comment");
    if (!comment)
        comment = append_section(".comment", line);

    // To match GAS output, if the comment section is empty, put an
    // initial 0 byte in the section.
    Bytecode& bc = comment->fresh_bytecode();
    if (comment->bcs_begin() == comment->bcs_end() && bc.get_fixed_len() == 0)
        append_byte(*comment, 0);

    for (NameValues::const_iterator nv=namevals.begin(), end=namevals.end();
         nv != end; ++nv)
    {
        if (!nv->is_string())
            throw ValueError(N_(".comment requires string parameters"));
        append_data(*comment, nv->get_string(), true);
    }
}

std::vector<std::string>
ElfObject::get_dbgfmt_keywords() const
{
    static const char* keywords[] =
    {
        "null",
        "stabs",
        "dwarf2"
    };
    return std::vector<std::string>(keywords, keywords+NELEMS(keywords));
}

void
ElfObject::add_directives(Directives& dirs, const std::string& parser)
{
    static const Directives::Init<ElfObject> nasm_dirs[] =
    {
        {"section", &ElfObject::dir_section, Directives::ARG_REQUIRED},
        {"segment", &ElfObject::dir_section, Directives::ARG_REQUIRED},
        {"type", &ElfObject::dir_type, Directives::ID_REQUIRED},
        {"size", &ElfObject::dir_size, Directives::ID_REQUIRED},
        {"weak", &ElfObject::dir_weak, Directives::ID_REQUIRED},
        {"ident", &ElfObject::dir_ident, Directives::ANY},
    };
    static const Directives::Init<ElfObject> gas_dirs[] =
    {
        {".section", &ElfObject::dir_section, Directives::ARG_REQUIRED},
        {".type", &ElfObject::dir_type, Directives::ID_REQUIRED},
        {".size", &ElfObject::dir_size, Directives::ID_REQUIRED},
        {".weak", &ElfObject::dir_weak, Directives::ID_REQUIRED},
        {".ident", &ElfObject::dir_ident, Directives::ANY},
    };

    if (String::nocase_equal(parser, "nasm"))
        dirs.add_array(this, nasm_dirs, NELEMS(nasm_dirs));
    else if (String::nocase_equal(parser, "gas"))
        dirs.add_array(this, gas_dirs, NELEMS(gas_dirs));
}
#if 0
static const char *elf_nasm_stdmac[] = {
    "%imacro type 1+.nolist",
    "[type %1]",
    "%endmacro",
    "%imacro size 1+.nolist",
    "[size %1]",
    "%endmacro",
    "%imacro weak 1+.nolist",
    "[weak %1]",
    "%endmacro",
    NULL
};

static const yasm_stdmac elf_objfmt_stdmacs[] = {
    { "nasm", "nasm", elf_nasm_stdmac },
    { NULL, NULL, NULL }
};
#endif
void
do_register()
{
    register_module<ObjectFormat, ElfObject>("elf");
    register_module<ObjectFormat, Elf32Object>("elf32");
    register_module<ObjectFormat, Elf64Object>("elf64");
}

}}} // namespace yasm::objfmt::elf
