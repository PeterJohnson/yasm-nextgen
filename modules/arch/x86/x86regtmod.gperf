#
# x86 register and target modifier recognition
#
#  Copyright (C) 2002-2007  Peter Johnson
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND OTHER CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR OTHER CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
%{
#include "modules/arch/x86/x86regtmod.h"

#include <util.h>

#include <cctype>
#include <cstring>

#include <libyasm/compose.h>
#include <libyasm/errwarn.h>
#include <libyasm/phash.h>

#include "modules/arch/x86/x86arch.h"

namespace yasm
{
namespace arch
{
namespace x86
{

unsigned int
X86Arch::get_size(const Register& reg) const
{
    assert(reg.m_arch == this);
    switch (yasm::arch::x86::get_type(reg))
    {
        case X86Register::NONE:
            return 0;
        case X86Register::REG8:
        case X86Register::REG8X:
            return 8;
        case X86Register::REG16:
            return 16;
        case X86Register::REG32:
        case X86Register::CRREG:
        case X86Register::DRREG:
        case X86Register::TRREG:
            return 32;
        case X86Register::REG64:
        case X86Register::MMXREG:
            return 64;
        case X86Register::XMMREG:
            return 128;
        case X86Register::FPUREG:
            return 80;
        default:
            assert(false);  // unknown register size
    }
    return 0;
}

void
X86Arch::put(std::ostream& os, const Register& reg) const
{
    static const char *name8[] = {"al","cl","dl","bl","ah","ch","dh","bh"};
    static const char *name8x[] =
    {
        "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil",
        "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b"
    };
    static const char *name16[] =
    {
        "ax", "cx", "dx", "bx", "sp", "bp", "si", "di"
        "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"
    };
    static const char *name32[] =
    {
        "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"
        "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
    };
    static const char *name64[] =
    {
        "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi"
        "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
    };

    assert(reg.m_arch == this);
    unsigned int num = get_num(reg);
    switch (yasm::arch::x86::get_type(reg))
    {
        case X86Register::REG8:
            os << name8[num&7];
            break;
        case X86Register::REG8X:
            os << name8x[num&0xF];
            break;
        case X86Register::REG16:
            os << name16[num&0xF];
            break;
        case X86Register::REG32:
            os << name32[num&0xF];
            break;
        case X86Register::REG64:
            os << name64[num&0xF];
            break;
        case X86Register::MMXREG:
            os << "mm" << num;
            break;
        case X86Register::XMMREG:
            os << "xmm" << num;
            break;
        case X86Register::CRREG:
            os << "cr" << num;
            break;
        case X86Register::DRREG:
            os << "dr" << num;
            break;
        case X86Register::TRREG:
            os << "tr" << num;
            break;
        case X86Register::FPUREG:
            os << "st" << num;
            break;
        default:
            assert(false);  // unknown register size
    }
}

Register
X86Arch::get_reg(const RegisterGroup& reggroup, unsigned int regindex) const
{
    assert(reggroup.m_arch == this);

    Register reg;
    reg.m_arch = this;
    reg.m_type = reggroup.m_type;
    reg.m_num = regindex;

    switch (yasm::arch::x86::get_type(reggroup))
    {
        case X86Register::XMMREG:
            if (m_mode_bits == 64 && regindex > 15)
                throw ValueError(N_("invalid register index"));
            /*@fallthrough@*/
        case X86Register::MMXREG:
        case X86Register::FPUREG:
            if (regindex > 7)
                throw ValueError(N_("invalid register index"));
            break;
        default:
            assert(false);  // bad register group
            throw ValueError(N_("bad register group"));
    }
    return reg;
}

void
X86Arch::put(std::ostream& os, const RegisterGroup& reggroup) const
{
    assert(reggroup.m_arch == this);
    switch (yasm::arch::x86::get_type(reggroup))
    {
        case X86Register::XMMREG:
            os << "xmm";
            break;
        case X86Register::MMXREG:
            os << "mm";
            break;
        case X86Register::FPUREG:
            os << "st";
            break;
        default:
            assert(false);
    }
}

void
X86Arch::put(std::ostream& os, const SegmentRegister& segreg) const
{
    assert(segreg.m_arch == this);
    static const char *name[] = {"es","cs","ss","ds","fs","gs"};
    assert(segreg.m_num < sizeof(name)/sizeof(name[0]));
    os << name[segreg.m_num&7];
}

unsigned char
get_prefix(const SegmentRegister& segreg)
{
    assert(!segreg.empty());
    static const unsigned char prefix[] = {0x26, 0x2e, 0x36, 0x3e, 0x64, 0x65};
    assert(segreg.m_num < sizeof(prefix)/sizeof(prefix[0]));
    return prefix[segreg.m_num&7];
}

void
X86Arch::put(std::ostream& os, const Insn::Operand::TargetModifier& tmod) const
{
    switch (yasm::arch::x86::get_type(tmod)) {
        case X86TargetModifier::NEAR:
            os << "near";
            break;
        case X86TargetModifier::SHORT:
            os << "short";
            break;
        case X86TargetModifier::FAR:
            os << "far";
            break;
        case X86TargetModifier::TO:
            os << "to";
            break;
    }
}

enum RegTmodType
{
    REG = 1,
    REGGROUP,
    SEGREG,
    TARGETMOD
};
%}
%ignore-case
%language=C++
%compare-strncmp
%readonly-tables
%enum
%struct-type
%define class-name RegTmodHash
struct RegTmodParseData {
    const char* name;

    unsigned int type:8;                // RegTmodType

    /* REG: register size
     * Others: 0
     */
    unsigned int size:8;

    /* REG: register index
     * REGGROUP: register group type
     * SEGREG: register encoding
     * TARGETMOD: target modifier
     */
    unsigned int data:8;

    // REG: required bits setting
    // SEGREG: BITS in which the segment is ignored
    // Others: 0
    unsigned int bits:8;
};
%%
#
# control, debug, and test registers
#
cr0,	REG,	X86Register::CRREG,	0,	0
cr2,	REG,	X86Register::CRREG,	2,	0
cr3,	REG,	X86Register::CRREG,	3,	0
cr4,	REG,	X86Register::CRREG,	4,	0
cr8,	REG,	X86Register::CRREG,	8,	64
#
dr0,	REG,	X86Register::DRREG,	0,	0
dr1,	REG,	X86Register::DRREG,	1,	0
dr2,	REG,	X86Register::DRREG,	2,	0
dr3,	REG,	X86Register::DRREG,	3,	0
dr4,	REG,	X86Register::DRREG,	4,	0
dr5,	REG,	X86Register::DRREG,	5,	0
dr6,	REG,	X86Register::DRREG,	6,	0
dr7,	REG,	X86Register::DRREG,	7,	0
#
tr0,	REG,	X86Register::TRREG,	0,	0
tr1,	REG,	X86Register::TRREG,	1,	0
tr2,	REG,	X86Register::TRREG,	2,	0
tr3,	REG,	X86Register::TRREG,	3,	0
tr4,	REG,	X86Register::TRREG,	4,	0
tr5,	REG,	X86Register::TRREG,	5,	0
tr6,	REG,	X86Register::TRREG,	6,	0
tr7,	REG,	X86Register::TRREG,	7,	0
#
# floating point, MMX, and SSE/SSE2 registers
#
st0,	REG,	X86Register::FPUREG,	0,	0
st1,	REG,	X86Register::FPUREG,	1,	0
st2,	REG,	X86Register::FPUREG,	2,	0
st3,	REG,	X86Register::FPUREG,	3,	0
st4,	REG,	X86Register::FPUREG,	4,	0
st5,	REG,	X86Register::FPUREG,	5,	0
st6,	REG,	X86Register::FPUREG,	6,	0
st7,	REG,	X86Register::FPUREG,	7,	0
#
mm0,	REG,	X86Register::MMXREG,	0,	0
mm1,	REG,	X86Register::MMXREG,	1,	0
mm2,	REG,	X86Register::MMXREG,	2,	0
mm3,	REG,	X86Register::MMXREG,	3,	0
mm4,	REG,	X86Register::MMXREG,	4,	0
mm5,	REG,	X86Register::MMXREG,	5,	0
mm6,	REG,	X86Register::MMXREG,	6,	0
mm7,	REG,	X86Register::MMXREG,	7,	0
#
xmm0,	REG,	X86Register::XMMREG,	0,	0
xmm1,	REG,	X86Register::XMMREG,	1,	0
xmm2,	REG,	X86Register::XMMREG,	2,	0
xmm3,	REG,	X86Register::XMMREG,	3,	0
xmm4,	REG,	X86Register::XMMREG,	4,	0
xmm5,	REG,	X86Register::XMMREG,	5,	0
xmm6,	REG,	X86Register::XMMREG,	6,	0
xmm7,	REG,	X86Register::XMMREG,	7,	0
xmm8,	REG,	X86Register::XMMREG,	8,	64
xmm9,	REG,	X86Register::XMMREG,	9,	64
xmm10,	REG,	X86Register::XMMREG,	10,	64
xmm11,	REG,	X86Register::XMMREG,	11,	64
xmm12,	REG,	X86Register::XMMREG,	12,	64
xmm13,	REG,	X86Register::XMMREG,	13,	64
xmm14,	REG,	X86Register::XMMREG,	14,	64
xmm15,	REG,	X86Register::XMMREG,	15,	64
#
# integer registers
#
rax,	REG,	X86Register::REG64,	0,	64
rcx,	REG,	X86Register::REG64,	1,	64
rdx,	REG,	X86Register::REG64,	2,	64
rbx,	REG,	X86Register::REG64,	3,	64
rsp,	REG,	X86Register::REG64,	4,	64
rbp,	REG,	X86Register::REG64,	5,	64
rsi,	REG,	X86Register::REG64,	6,	64
rdi,	REG,	X86Register::REG64,	7,	64
r8,	REG,	X86Register::REG64,	8,	64
r9,	REG,	X86Register::REG64,	9,	64
r10,	REG,	X86Register::REG64,	10,	64
r11,	REG,	X86Register::REG64,	11,	64
r12,	REG,	X86Register::REG64,	12,	64
r13,	REG,	X86Register::REG64,	13,	64
r14,	REG,	X86Register::REG64,	14,	64
r15,	REG,	X86Register::REG64,	15,	64
#
eax,	REG,	X86Register::REG32,	0,	0
ecx,	REG,	X86Register::REG32,	1,	0
edx,	REG,	X86Register::REG32,	2,	0
ebx,	REG,	X86Register::REG32,	3,	0
esp,	REG,	X86Register::REG32,	4,	0
ebp,	REG,	X86Register::REG32,	5,	0
esi,	REG,	X86Register::REG32,	6,	0
edi,	REG,	X86Register::REG32,	7,	0
r8d,	REG,	X86Register::REG32,	8,	64
r9d,	REG,	X86Register::REG32,	9,	64
r10d,	REG,	X86Register::REG32,	10,	64
r11d,	REG,	X86Register::REG32,	11,	64
r12d,	REG,	X86Register::REG32,	12,	64
r13d,	REG,	X86Register::REG32,	13,	64
r14d,	REG,	X86Register::REG32,	14,	64
r15d,	REG,	X86Register::REG32,	15,	64
#
ax,	REG,	X86Register::REG16,	0,	0
cx,	REG,	X86Register::REG16,	1,	0
dx,	REG,	X86Register::REG16,	2,	0
bx,	REG,	X86Register::REG16,	3,	0
sp,	REG,	X86Register::REG16,	4,	0
bp,	REG,	X86Register::REG16,	5,	0
si,	REG,	X86Register::REG16,	6,	0
di,	REG,	X86Register::REG16,	7,	0
r8w,	REG,	X86Register::REG16,	8,	64
r9w,	REG,	X86Register::REG16,	9,	64
r10w,	REG,	X86Register::REG16,	10,	64
r11w,	REG,	X86Register::REG16,	11,	64
r12w,	REG,	X86Register::REG16,	12,	64
r13w,	REG,	X86Register::REG16,	13,	64
r14w,	REG,	X86Register::REG16,	14,	64
r15w,	REG,	X86Register::REG16,	15,	64
#
al,	REG,	X86Register::REG8,	0,	0
cl,	REG,	X86Register::REG8,	1,	0
dl,	REG,	X86Register::REG8,	2,	0
bl,	REG,	X86Register::REG8,	3,	0
ah,	REG,	X86Register::REG8,	4,	0
ch,	REG,	X86Register::REG8,	5,	0
dh,	REG,	X86Register::REG8,	6,	0
bh,	REG,	X86Register::REG8,	7,	0
r8b,	REG,	X86Register::REG8,	8,	64
r9b,	REG,	X86Register::REG8,	9,	64
r10b,	REG,	X86Register::REG8,	10,	64
r11b,	REG,	X86Register::REG8,	11,	64
r12b,	REG,	X86Register::REG8,	12,	64
r13b,	REG,	X86Register::REG8,	13,	64
r14b,	REG,	X86Register::REG8,	14,	64
r15b,	REG,	X86Register::REG8,	15,	64
#
spl,	REG,	X86Register::REG8X,	4,	64
bpl,	REG,	X86Register::REG8X,	5,	64
sil,	REG,	X86Register::REG8X,	6,	64
dil,	REG,	X86Register::REG8X,	7,	64
#
rip,	REG,	X86Register::RIP,	0,	64
#
# floating point, MMX, and SSE/SSE2 registers
#
st,	REGGROUP,	0,	X86Register::FPUREG,	0
mm,	REGGROUP,	0,	X86Register::MMXREG,	0
xmm,	REGGROUP,	0,	X86Register::XMMREG,	0
#
# segment registers
#
es,	SEGREG,	0,	X86SegReg::ES,	64
cs,	SEGREG,	0,	X86SegReg::CS,	0
ss,	SEGREG,	0,	X86SegReg::SS,	64
ds,	SEGREG,	0,	X86SegReg::DS,	64
fs,	SEGREG,	0,	X86SegReg::FS,	0
gs,	SEGREG,	0,	X86SegReg::GS,	0
#
# target modifiers
#
near,	TARGETMOD,	0,	X86TargetModifier::NEAR,	0
short,	TARGETMOD,	0,	X86TargetModifier::SHORT,	0
far,	TARGETMOD,	0,	X86TargetModifier::FAR,		0
to,	TARGETMOD,	0,	X86TargetModifier::TO,		0
%%

Arch::RegTmod
X86Arch::parse_check_regtmod(const char* id, size_t id_len) const
{
    if (id_len > 7)
        return RegTmod();

    static char lcaseid[8];
    for (size_t i=0; i<id_len; i++)
        lcaseid[i] = std::tolower(id[i]);
    lcaseid[id_len] = '\0';

    const RegTmodParseData* pdata = RegTmodHash::in_word_set(lcaseid, id_len);
    if (!pdata)
        return RegTmod();

    unsigned int bits = pdata->bits;

    switch ((RegTmodType)pdata->type)
    {
        case REG:
        {
            if (bits != 0 && m_mode_bits != bits)
            {
                warn_set(WARN_GENERAL,
                    String::compose(N_("`%1' is a register in %2-bit mode"),
                                    id, bits));
                return RegTmod();
            }
            Register reg;
            reg.m_arch = this;
            reg.m_type = pdata->size;
            reg.m_num = pdata->data;
            return reg;
        }
        case REGGROUP:
        {
            RegisterGroup reggroup;
            reggroup.m_arch = this;
            reggroup.m_type = pdata->data;
            return reggroup;
        }
        case SEGREG:
        {
            if (bits != 0 && m_mode_bits == bits)
            {
                warn_set(WARN_GENERAL, String::compose(
                    N_("`%1' segment register ignored in %2-bit mode"),
                    id, bits));
            }
            SegmentRegister segreg;
            segreg.m_arch = this;
            segreg.m_num = pdata->data;
            return segreg;
        }
        case TARGETMOD:
        {
            Insn::Operand::TargetModifier tmod;
            tmod.m_arch = this;
            tmod.m_type = pdata->data;
            return tmod;
        }
    }

    return RegTmod();
}

}}} // namespace yasm::arch::x86
